:toc:
:numbered:
:data-uri:

----
> library("trioClasses")
----
== Construct CNV Matrix ==
Before any analysis begins we construct the CNV matrix.  This matrix is a matrix containing 0,1,2 for number of deletions at a CNV component.  Each row corresponds to a subject, and each column to a cnv component.
----
> library("trioClasses")
> source("~/jhsph/R/packages/CleftCNVAssoc/vignettes/curated/make-data.R")
> gr.deletion.beaty <- gr.beaty[values(gr.beaty)$numsnp >= 10 & values(gr.beaty)$cn %in% 0:1 ]
> homos.beaty <- with(values(gr.deletion.beaty),cn==0)
> gr.deletion.pitt <- gr.pitt[values(gr.pitt)$numsnp >= 10 & values(gr.pitt)$cn %in% 0:1 ]
> homos.pitt <- with(values(gr.deletion.pitt),cn==0)
> gr.deletion.beaty.clean <- c( unlist(reduce(split(gr.deletion.beaty, values(gr.deletion.beaty)$id))), unlist(reduce(split(gr.deletion.beaty[homos.beaty], values(gr.deletion.beaty[homos.beaty])$id))))
> gr.deletion.pitt.clean <- c( unlist(reduce(split(gr.deletion.pitt, values(gr.deletion.pitt)$id))), unlist(reduce(split(gr.deletion.pitt[homos.pitt], values(gr.deletion.pitt[homos.pitt])$id))))
----
Now with these GRanges objects we use the trioClasses function CNVMatrix to construct the CNV matrices.
----
> system.time( cnv.obj.beaty <- CNVMatrix( gr.deletion.beaty.clean, gr = gr.deletion.pitt.clean ) )
> system.time( cnv.obj.pitt <- CNVMatrix( gr.deletion.pitt.clean, gr = gr.deletion.beaty.clean ) )
> save( cnv.obj.beaty, cnv.obj.pitt, file = "./../data/cnv.RData" )
----

== Make Data ==
Now we use the CNV matrix as part of a FamilyExperiment object, as defined in trioClasses.  With the FE object we may easily acces trio-states of CNV components and regions.
----
>   library("CleftCNVAssoc")
>   data("pedigrees", package="CleftCNVAssoc")
>   data("cnv", package = "trioClasses")
----
Now we create the FamilyExperiment for the cleft group.
----
> fe.beaty
class: FamilyExperiment 
dim: 7256 1339 
exptData(0):
assays(1): cnv
rownames(7256): comp1 comp2 ... comp7255 comp7256
rowData metadata column names(0):
colnames(1339): 11005_01@1008472480 11005_02@1008472482 ...
  18117_02@0070298660 18117_03@0070298657
colData names(1): id
pedigree(2082): famid id fid mid sex dx
complete trios(445):
----
The control group.
----
> fe.pitt
class: FamilyExperiment 
dim: 7256 902 
exptData(0):
assays(1): cnv
rownames(7256): comp1 comp2 ... comp7255 comp7256
rowData metadata column names(0):
colnames(902): 173000367@0070353602 173000562@0070278291 ...
  175198958@0070318441 175199696@0072922513
colData names(1): id
pedigree(752): famid id fid mid sex dx
complete trios(391):
----

== Association (Component-wise) ==
Our first idea was to do a two by two test on the transmitted and non-transmitted counts in clefts and controls.  In the process of doing so we identified regions of under-transmission, as well as a few signifcany regions.

// The above must have been written before the MAF method was implemented.
Compute a DataFrame containing counts of transmissions by case/control with rows for components.  This is partly what distinguishes a DataFrame from a data.frame --- the ability to keep a GRanges object in a column.
----
> TU.mat.beaty <- matrix(unlist(lapply(table.list.beaty, trioClasses:::CountTU)), nrow = length(table.list.beaty), ncol = 2, byrow = TRUE )
> TU.mat.pitt <- matrix(unlist(lapply(table.list.pitt, trioClasses:::CountTU)), nrow = length(table.list.pitt), ncol = 2, byrow = TRUE )
> TU.mat <- cbind(TU.mat.beaty, TU.mat.pitt)
> testable <- which(   (rowSums(TU.mat[,1:2])>=25) & (rowSums(TU.mat[,3:4])>=25) )
> TU.mat <- TU.mat[testable,]
> rownames(TU.mat) <- names(table.list.beaty)[testable]
> colnames(TU.mat) <- c("T.case","U.case","T.con","U.con")
> DF <- DataFrame(rowData(fe.beaty)[testable],TU.mat)
> colnames(DF) <- c("grange", colnames(TU.mat))
----
Now with that DataFrame we construct a histogram of overall transmission rate by component.
----
> hist(trans.vec <- rowSums(TU.mat[,c(1,3)])/rowSums(TU.mat), breaks = 20)
----
image::figures/fig-hist.jpg[]

Histogram of transmission rate component-wise.  We see a clear bimodal distribution.
Number of components and number of regions is given below.
----
> c(length(DF$grange),length(reduce(DF$grange)))
[1] 632  45
----
image::figures/fig-qqplot.jpg[]




image::figures/fig-transvp.jpg[]

The outlier is on chromsome 16.  It is a region with 123 components, and has width 125.535 kB. chr16:32404517-32530051.  

image::figures/fig-cumsum.jpg[]

image::figures/fig-transmedianhist.jpg[]

image::figures/fig-qqplot-clean.jpg[]

image::figures/fig-cumsum2.jpg[]


== Association (Region-wise) ==
Note that this uses a very strict definition for non-transmitted.  To be non-transmitted a region must have no component in region with a trio-state that indicates non-transmission.  This may bias the estimate towards over-transmission.

First we see how many regions there are to begin with.
----
> reduce(rowData(fe.beaty))
GRanges with 2237 ranges and 0 metadata columns:
         seqnames               ranges strand
            <Rle>            <IRanges>  <Rle>
     [1]     chr1   [ 354188,  613900]      *
     [2]     chr1   [ 836671, 1617665]      *
     [3]     chr1   [1672234, 1782971]      *
     [4]     chr1   [2072349, 2564816]      *
     [5]     chr1   [2689509, 2739781]      *
     [6]     chr1   [2782661, 2840041]      *
     [7]     chr1   [2859773, 3037112]      *
     [8]     chr1   [3187607, 3201318]      *
     [9]     chr1   [3265998, 3298358]      *
     ...      ...                  ...    ...
  [2229]    chr22 [45833328, 45882946]      *
  [2230]    chr22 [45919059, 45945408]      *
  [2231]    chr22 [47310862, 47334116]      *
  [2232]    chr22 [47414612, 47441180]      *
  [2233]    chr22 [47520376, 47559621]      *
  [2234]    chr22 [47791598, 47892761]      *
  [2235]    chr22 [47983471, 48039811]      *
  [2236]    chr22 [48892935, 49130879]      *
  [2237]    chr22 [49276447, 49337535]      *
  ---
  seqlengths:
            chr1   chr1_random          chr2   chr2_random          chr3 ...          chrX   chrX_random          chrY          chrM
       247249719       1663265     242951149        185571     199501827 ...     154913754       1719168      57772954         16571
----
But many of these are rare.  Later we filter out the rare regions. Foo!
Note that we exclude any region made up of only on component.
----
> TU.mat <- trans.mat
> testable <- which(   (rowSums(TU.mat[,1:2])>=25) & (rowSums(TU.mat[,3:4])>=25) )
> TU.mat <- TU.mat[testable,]
----
----
> trioClasses:::TU.fish
function (TU.vec) 
{
    if (!identical(c("T.case", "U.case", "T.con", "U.con"), names(TU.vec))) 
        return("TU vector must have the correct names.")
    fish <- fisher.test(matrix(TU.vec, nrow = 2, ncol = 2, byrow = TRUE), 
        alternative = "greater")
    return(fish)
}
<environment: namespace:trioClasses>
----
----
> fish.list <- apply(TU.mat,1,trioClasses:::TU.fish)
> p.vec <- unlist( lapply( fish.list, function(obj) return(obj$p.value) ) )
> DF <- DataFrame(DF,p.vec,transrate.all[testable])
> head(as(DF[with(as(DF,"data.frame"),order(p.vec)),],"data.frame"))
  grange.seqnames grange.start grange.end grange.width grange.strand T.case U.case T.con U.con p.vec transrate.all.testable.
1            chr1    103899238  104126342       227105             *     48     39    39    41 0.250                   0.521
2            chr1     12769266   13058015       288750             *     23     13    14    12 0.297                   0.597
3            chr1    147272181  147849072       576892             *      8     32    34    87 0.890                   0.261
----
----
> nrow(DF)
[1] 3
> head(as(DF[with(as(DF,"data.frame"),order(transrate.all.testable.)),],"data.frame"))
  grange.seqnames grange.start grange.end grange.width grange.strand T.case U.case T.con U.con p.vec transrate.all.testable.
1            chr1    147272181  147849072       576892             *      8     32    34    87 0.890                   0.261
2            chr1    103899238  104126342       227105             *     48     39    39    41 0.250                   0.521
3            chr1     12769266   13058015       288750             *     23     13    14    12 0.297                   0.597
----
----
> hist(DF$transrate.all.testable.)
----
image::figures/fig-transhist.jpg[]

----
> htest.list.cleft <- list(NA, length = nrow(TU.mat))
> for( i in 1:nrow(TU.mat) ){
      htest.list.cleft[[i]] <- binom.test(TU.mat[i,"T.case"],sum(TU.mat[i,c("T.case","U.case")]))
 }
> ci.list.cleft <- lapply(htest.list.cleft, trioClasses:::get.ci)
> ci.mat.cleft <- matrix(unlist(ci.list.cleft),nrow = length(htest.list.cleft), ncol = 2, byrow = TRUE )
> o <- order(DF$transrate.all.testable.)
> plot(1, type = "n", xlim = c(1,nrow(ci.mat.cleft)), ylim = c(0,1), xlab = "Deleted Regions", ylab = "Cleft Transmission Rate", main = "" )
> polygon( x = c(x <- 1:nrow(ci.mat.cleft), rev(x)), y = c(ci.mat.cleft[o,1],rev(ci.mat.cleft[o,2])),col = "orange", border = "black")
> lines( c(1,nrow(ci.mat.cleft)), rep(0.5,2), lty = 3 )
----
image::figures/fig-cifigcleft.jpg[]

image::figures/fig-cifigcon.jpg[]

image::figures/fig-cifigall.jpg[]

.How do we filter regions that are undertransmitted?
* Any region whose overall transmission rate CI does not cover 0.5

== Session Info ==
----
> sessionInfo()
R version 3.0.0 (2013-04-03)
Platform: x86_64-unknown-linux-gnu (64-bit)

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    LC_PAPER=C                 LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] splines   parallel  stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] TxDb.Hsapiens.UCSC.hg18.knownGene_2.9.0 GenomicFeatures_1.12.2                  AnnotationDbi_1.21.10                  
 [4] CleftCNVAssoc_0.0.2                     MinimumDistance_1.3.6                   GWASTools_1.5.8                        
 [7] sandwich_2.2-9                          zoo_1.7-9                               gdsfmt_0.9.11                          
[10] ncdf_1.6.6                              Biobase_2.19.2                          trioClasses_1.0.6                      
[13] snpStats_1.9.2                          Matrix_1.0-12                           lattice_0.20-15                        
[16] survival_2.37-4                         GenomicRanges_1.11.29                   IRanges_1.17.31                        
[19] BiocGenerics_0.5.6                      cacheSweave_0.6-1                       stashR_0.3-5                           
[22] filehash_2.2-1                          ascii_2.1                              

loaded via a namespace (and not attached):
 [1] affyio_1.27.1        BiocInstaller_1.10.1 biomaRt_2.15.0       Biostrings_2.27.11   bit_1.1-9            bitops_1.0-5        
 [7] BSgenome_1.27.1      codetools_0.2-8      DBI_0.2-5            digest_0.6.3         DNAcopy_1.33.1       ff_2.2-10           
[13] foreach_1.4.0        grid_3.0.0           GWASExactHW_1.01     iterators_1.0.6      lmtest_0.9-30        matrixStats_0.6.2   
[19] msm_1.1.4            mvtnorm_0.9-9994     oligoClasses_1.21.14 quantsmooth_1.25.0   RCurl_1.95-3         R.methodsS3_1.4.2   
[25] Rsamtools_1.11.16    RSQLite_0.11.2       rtracklayer_1.19.9   stats4_3.0.0         tools_3.0.0          VanillaICE_1.21.26  
[31] XML_3.95-0.1         zlibbioc_1.5.0      
----
