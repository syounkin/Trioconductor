:toc:
:numbered:
:data-uri:

<<junk,echo=FALSE>>=    Somehow, this avoids the "figure margins too large" error ~kbroman
par(mar=rep(0,4))
par(bg="white")
options(width=1000, continue="  ")
@ 

<<package, echo = TRUE, eval = TRUE, cache = FALSE>>=
system("R CMD INSTALL ~/jhsph/R/packages/CleftCNVAssoc") # Before installing CleftCNVAssoc be sure that the vignette data-cleaning has been run
system("R CMD INSTALL ~/Trioconductor")
library("Trioconductor")
@

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~ Data Creation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

== Construct CNV Matrix ==

Before any analysis begins we construct the CNV matrix.  This matrix
is a matrix containing 0,1,2 for number of deletions at a CNV
component.  Each row corresponds to a subject, and each column to a
cnv component.

<<makedata, echo = FALSE, eval = FALSE>>=
source("~/jhsph/R/packages/CleftCNVAssoc/vignettes/curated/make-data.R")
gr.deletion.beaty <- gr.beaty[values(gr.beaty)$numsnp >= 10 & values(gr.beaty)$cn %in% 0:1 ]
ids.with.no.deletion.beaty <- c()
if( length(unique(values(gr.deletion.beaty)$id)) < length(unique(values(gr.beaty)$id))){
    message("Some beaty subject(s) have zero deletions that pass requirements.")
    indx <- which(!(unique(values(gr.beaty)$id) %in% unique(values(gr.deletion.beaty)$id)))
    ids.with.no.deletion.beaty <- as.character(unique(values(gr.beaty)$id)[indx])
}
homos.beaty <- with(values(gr.deletion.beaty),cn==0)
# This is an important step that should be well-described and checked!
gr.deletion.beaty.clean <- c( unlist(reduce(split(gr.deletion.beaty, values(gr.deletion.beaty)$id))), unlist(reduce(split(gr.deletion.beaty[homos.beaty], values(gr.deletion.beaty[homos.beaty])$id))))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
gr.deletion.pitt <- gr.pitt[values(gr.pitt)$numsnp >= 10 & values(gr.pitt)$cn %in% 0:1 ]
ids.with.no.deletion.pitt <- c()
if( length(unique(values(gr.deletion.pitt)$id)) < length(unique(values(gr.pitt)$id))){
    message("Some pitt subject(s) have zero deletions that pass requirements.")
    indx <- which(!(unique(values(gr.pitt)$id) %in% unique(values(gr.deletion.pitt)$id)))
    ids.with.no.deletion.pitt <- as.character(unique(values(gr.pitt)$id)[indx])
}
homos.pitt <- with(values(gr.deletion.pitt),cn==0)
# This is an important step that should be well-described and checked!
gr.deletion.pitt.clean <- c( unlist(reduce(split(gr.deletion.pitt, values(gr.deletion.pitt)$id))), unlist(reduce(split(gr.deletion.pitt[homos.pitt], values(gr.deletion.pitt[homos.pitt])$id))))
@ 

Now with these GRanges objects we use the Trioconductor function CNVMatrix to construct the CNV matrices.

<<cnvmatrix, echo = FALSE, eval = FALSE, cache = FALSE>>=
system.time( cnv.obj.beaty <- CNVMatrix( gr.deletion.beaty.clean, gr = gr.deletion.pitt.clean ) )
system.time( cnv.obj.pitt <- CNVMatrix( gr.deletion.pitt.clean, gr = gr.deletion.beaty.clean ) )
#Here is were we add rows of zeros to cnv.mat
cnv.obj.beaty$cnv.mat <- rbind(cnv.obj.beaty$cnv.mat,matrix(0,nrow=length(ids.with.no.deletion.beaty),ncol=ncol(cnv.obj.beaty$cnv.mat),dimnames=list(ids.with.no.deletion.beaty,colnames(cnv.obj.beaty$cnv.mat))))
cnv.obj.pitt$cnv.mat <- rbind(cnv.obj.pitt$cnv.mat,matrix(0,nrow=length(ids.with.no.deletion.pitt),ncol=ncol(cnv.obj.pitt$cnv.mat),dimnames=list(ids.with.no.deletion.pitt,colnames(cnv.obj.pitt$cnv.mat))))
save( cnv.obj.beaty, cnv.obj.pitt, file = "./../data/cnv.RData" )
system("R CMD INSTALL ~/Trioconductor")
source("~/Trioconductor/R/reload.R")
reload("Trioconductor")
@ 

== Make Data ==
Now we use the CNV matrix as part of a FamilyExperiment object, as defined in Trioconductor.  With the FE object we may easily acces trio-states of CNV components and regions.
<<options, echo = FALSE, eval = FALSE >>=
  #data("cnv", package = "Trioconductor")
  load(file = "./../data/cnv.RData")
  data("pedigrees", package = "CleftCNVAssoc")
  data("clean-samples", package = "CleftCNVAssoc")
@ 
Now we create the FamilyExperiment for the cleft group.
<<se-beaty, echo = FALSE, eval = FALSE>>=
  se.beaty <- SummarizedExperiment(assays = SimpleList(cnv = t(cnv.obj.beaty$cnv.mat)), colData = DataFrame(id=rownames(cnv.obj.beaty$cnv.mat), row.names = rownames(cnv.obj.beaty$cnv.mat)), rowData = cnv.obj.beaty$cmp.gr )
  beaty.trios <- MinimumDistance:::trios(beaty.pedigree)
  beaty.ped <- DataFrame(famid = do.call("rbind",strsplit(beaty.trios$O, "_" ))[,1], id = beaty.trios$O, fid = beaty.trios$F, mid = beaty.trios$M, sex = NA, dx = NA)
  ped <- PedClass(beaty.ped)
  fe.beaty <- FamilyExperiment(se.beaty, pedigree = ped )
  cD <- merge(colData(fe.beaty),beaty.clean.strict,by.x  = "id", by.y="Sample.Name", all.x = TRUE, sort = FALSE)
  rownames(cD) <- cD$id
  colData(fe.beaty) <- cD
@ 
<<fe-beaty, echo = FALSE, eval = FALSE, cache = FALSE>>=
(fe.beaty.pheno <- fe.beaty)
@
The control group.
<<se-pitt, echo = FALSE, eval = FALSE>>=
  se.pitt <- SummarizedExperiment(assays = SimpleList(cnv = t(cnv.obj.pitt$cnv.mat)), colData = DataFrame(id=rownames(cnv.obj.pitt$cnv.mat), row.names = rownames(cnv.obj.pitt$cnv.mat)), rowData = cnv.obj.pitt$cmp.gr )
  pitt.trios <- MinimumDistance:::trios(pitt.pedigree)
  pitt.ped <- DataFrame(famid = pitt.trios$O, id = pitt.trios$O, fid = pitt.trios$F, mid = pitt.trios$M, sex = NA, dx = NA)
  ped.pitt <- PedClass(pitt.ped)
  fe.pitt <- FamilyExperiment(se.pitt, pedigree = ped.pitt )
  cD <- merge(colData(fe.pitt),pitt.clean.strict, by.x  = "id", by.y="Sample.Name", all.x = TRUE, sort = FALSE)
  rownames(cD) <- cD$id
  colData(fe.pitt) <- cD

@ 
<<fe-pitt, echo = FALSE, eval = FALSE, cache = FALSE>>=
fe.pitt
@
<<save, echo = FALSE, eval = FALSE, cache = FALSE>>=
save(fe.beaty, fe.pitt, fe.beaty.pheno, file = "./../data/fe.RData" )
system("R CMD INSTALL ~/Trioconductor")
source("~/Trioconductor/R/reload.R")
reload("Trioconductor")
@ 

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~ Analysis ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

== Association (Component-wise) ==
Our first idea was to do a two by two test on the transmitted and non-transmitted counts in clefts and controls.  In the process of doing so we identified regions of under-transmission, as well as a few signifcany regions.
<<options, echo=FALSE, eval = TRUE, echo = TRUE, cache = FALSE>>=
setCacheDir("sgy-cache")
options(width=132, digits=3, scipen=4, continue =" ")
system("R CMD INSTALL ~/Trioconductor")
source("./../R/reload.R")
reload("Trioconductor")
#library(Trioconductor)
library("TxDb.Hsapiens.UCSC.hg18.knownGene")
load(file = "./../data/fe.RData")
#data("fe", package = "Trioconductor")
fe.beaty
fe.pitt
fe.beaty.pheno
#data("pedigrees", package="CleftCNVAssoc")
#data("penncnvjoint", package = "CleftCNVAssoc")
#load(file = "./../data/cnv.RData")
#data("cnv", package = "Trioconductor")
@ 

<<FamilyExperiment, echo = TRUE, eval = TRUE, cache = FALSE>>=
  fe.beaty.parents <- fe.beaty[,colnames(fe.beaty)%in%parents(fe.beaty)]
  fe.pitt.parents <- fe.pitt[,colnames(fe.pitt)%in%parents(fe.pitt)]
@

<<freq-vec, echo = FALSE, eval = FALSE, cache = FALSE>>=
    freq.beaty.vec <- colSums(cnv(fe.beaty.parents))/nrow(cnv(fe.beaty.parents))
    freq.pitt.vec <- colSums(cnv(fe.pitt.parents))/nrow(cnv(fe.pitt.parents))
@

// The above must have been written before the MAF method was implemented.

<<trioStates, eval = TRUE, echo = TRUE, cache = FALSE>>=
    trioAssay.beaty <- Trioconductor:::TrioAssay(fe.beaty, type = "cnv")
    trioStates.beaty <- with(trioAssay.beaty, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.beaty) <- dimnames(trioAssay.beaty$O)
    trioAssay.pitt <- Trioconductor:::TrioAssay(fe.pitt, type = "cnv")
    trioStates.pitt <- with(trioAssay.pitt, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.pitt) <- dimnames(trioAssay.pitt$O)
@

<<table-list, eval = TRUE, echo = TRUE, cache = FALSE>>=
    table.list.beaty <- apply(trioStates.beaty, 2, "table")
    table.list.pitt <- apply(trioStates.pitt, 2, "table")
@ 

Compute a DataFrame containing counts of transmissions by case/control
with rows for components.  This is partly what distinguishes a
DataFrame from a data.frame --- the ability to keep a GRanges object
in a column.

<<TU, eval = TRUE, echo = TRUE, cache = FALSE>>=
TU.mat.beaty <- matrix(unlist(lapply(table.list.beaty, Trioconductor:::CountTU)), nrow = length(table.list.beaty), ncol = 2, byrow = TRUE )
TU.mat.pitt <- matrix(unlist(lapply(table.list.pitt, Trioconductor:::CountTU)), nrow = length(table.list.pitt), ncol = 2, byrow = TRUE )
TU.mat <- cbind(TU.mat.beaty, TU.mat.pitt)
colnames(TU.mat) <- c("T.case","U.case","T.con","U.con")
rownames(TU.mat) <- names(table.list.beaty)
gr.cmp <- rowData(fe.beaty)
testable <- which(   (rowSums(TU.mat[,1:2])>=25) & (rowSums(TU.mat[,3:4])>=25) )
length(testable)
TU.mat <- TU.mat[testable,]
TU.mat.cmp <- TU.mat
DF <- DataFrame(rowData(fe.beaty)[testable],TU.mat)
colnames(DF) <- c("grange", colnames(TU.mat))
@ 

Now with that DataFrame we construct a histogram of overall transmission rate by component.
<<hist, fig = TRUE, eval = TRUE, echo = TRUE, cache = FALSE>>=
hist(trans.vec <- rowSums(TU.mat[,c(1,3)])/rowSums(TU.mat), breaks = 20)
@ 

Histogram of transmission rate component-wise.  We see a clear bimodal distribution.

<<fish, eval = TRUE, echo = TRUE, cache = FALSE>>=
fish.list <- apply(TU.mat,1,Trioconductor:::TU.fish)
p.vec <- unlist( lapply( fish.list, function(obj) return(obj$p.value) ) )
(DF <- DataFrame(DF,p.vec, trans.vec))
DF.cmp <- DF
@ 

Number of components and number of regions is given below.

<<length1, echo = TRUE, eval = TRUE, cache = FALSE>>=
c(length(DF$grange),length(reduce(DF$grange)))
@ 

=== Figures ===

<<qqplot, fig = TRUE, eval = TRUE, echo = TRUE, cache = FALSE>>=
n <- nrow(DF)
plot( -log10((1:n)/n), -log10(DF$p.vec[order(DF$p.vec)]), xlim = xlim <- c(0,5), ylim = xlim)
lines( c(0,xlim[2]), c(0,xlim[2]), lty = 3 )
@ 


<<pmin, eval = TRUE, echo = TRUE, cache = FALSE>>=
regions.gr <- reduce(DF$grange)
index.vec <- subjectHits(findOverlaps(DF$grange,regions.gr))
DF.list <- split(DF, index.vec)
p.min.DF <- Trioconductor:::f.cmp( DF, "p.vec", min, na.rm = TRUE )
n.DF <- Trioconductor:::f.cmp( DF, "p.vec", function(vec){sum(!is.na(vec), na.rm = TRUE)})
p.median.DF <- Trioconductor:::f.cmp( DF, "p.vec", median, na.rm = TRUE )
trans.median.DF <- Trioconductor:::f.cmp( DF, "trans.vec", median, na.rm = TRUE )
@

<<meta, eval = TRUE, echo = TRUE, cache = FALSE>>=
meta <- values(regions.gr)
meta <- DataFrame(meta, p.min = p.min.DF$value, p.median = p.median.DF$value, trans.median = trans.median.DF$value, n.cmp = n.DF$value)
values(regions.gr) <- meta
@

<<tophits, eval = TRUE, echo = TRUE, cache = FALSE>>=
head(as(regions.gr[order(values(regions.gr)$p.min)],"data.frame"),25)
@ 

<<transvp, fig = TRUE, eval = TRUE, echo = TRUE, cache = FALSE>>=
layout(mat=matrix(1:4, nrow = 2, ncol = 2 ))
with(as(values(regions.gr),"data.frame"),plot(trans.median, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, trans.median, pch = 20))
with(as(values(regions.gr),"data.frame"),plot(width(regions.gr)/1e3, n.cmp, pch = 20))
@

<<chr16, eval = TRUE, echo = TRUE, cache = FALSE>>=
(bad.region.gr <- regions.gr[which(values(regions.gr)$n.cmp >= 120)])
@

The outlier is on chromsome 16.  It is a region with \Sexpr{values(bad.region.gr)$n.cmp} components, and has width \Sexpr{width(bad.region.gr)/1e3} kB. chr16:\Sexpr{start(bad.region.gr)}-\Sexpr{end(bad.region.gr)}.  

<<transvp2, fig = TRUE, eval = TRUE, echo = TRUE, cache = FALSE>>=
regions.gr <- regions.gr[-which(values(regions.gr)$n.cmp >= 120)]
layout(mat=matrix(1:4, nrow = 2, ncol = 2 ))
with(as(values(regions.gr),"data.frame"),plot(trans.median, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, trans.median, pch = 20))
with(as(values(regions.gr),"data.frame"),plot(width(regions.gr), n.cmp, pch = 20))
@ 
<<cumsum, fig = TRUE, width = 8, eval = TRUE, echo = TRUE, cache = FALSE>>=
TranscriptDb <- TxDb.Hsapiens.UCSC.hg18.knownGene
chrlength <- c(0,seqlengths(TranscriptDb)[paste0("chr",1:22)])
names(chrlength) <- c(names(chrlength[-1]),"foo")
chrlength <- rev(rev(chrlength)[-1])
chrstart <- cumsum(chrlength)

plot(1, type = "n", xlim = c(1,3e9), ylim = c(0,6 ), axes = FALSE, xlab = "", ylab = "" )
for( i in 1:length(regions.gr) ){
  points( chrstart[as(seqnames(regions.gr[i]),"character")] + start(DF.list[[i]]$grange), -log10(DF.list[[i]]$p.vec), pch = 20, col = i)
}
axis(1, chrstart, label = paste0("chr",1:length(chrstart)))
axis(2)
@ 
<<transmedianhist, fig = TRUE, eval = TRUE, echo = TRUE, cache = FALSE>>=
with(as(values(regions.gr),"data.frame"),hist(trans.median))
@ 
<<thresh, echo = TRUE, cache = FALSE, eval = TRUE>>=
thresh <- with(as(values(regions.gr),"data.frame"),median(trans.median))
regions.gr.clean <- regions.gr[which(values(regions.gr)$trans.median >= thresh)]
DF.clean <- DF[queryHits(findOverlaps(DF$grange, regions.gr.clean)),]

@ 
<<qqplot-clean, fig = TRUE, eval = TRUE, echo = TRUE, cache = FALSE>>=
n <- nrow(DF.clean)
plot( -log10((1:n)/n), -log10(DF.clean$p.vec[order(DF.clean$p.vec)]), xlim = xlim <- c(0,5), ylim = xlim)
lines( c(0,xlim[2]), c(0,xlim[2]), lty = 3 )
@ 
<<cumsum2, fig = TRUE, width = 8, eval = TRUE, echo = TRUE, cache = FALSE>>=
index.vec <- subjectHits(findOverlaps(DF.clean$grange,regions.gr.clean))
DF.clean.list <- split(DF.clean, index.vec)

plot(1, type = "n", xlim = c(1,3e9), ylim = c(0,6 ), axes = FALSE, xlab = "", ylab = "" )
for( i in 1:length(regions.gr.clean) ){
  points( chrstart[as(seqnames(regions.gr.clean[i]),"character")] + start(DF.clean.list[[i]]$grange), -log10(DF.clean.list[[i]]$p.vec), pch = 20, col = i)
}
lines( c(1,(chrstart+chrlength)[22]), rep(-log10(0.05/n),2), lty = 3)
axis(1, chrstart, label = paste0("chr",1:length(chrstart)))
axis(2)
@ 
<<phist, fig = TRUE,  eval = TRUE, echo = TRUE, cache = FALSE>>=
with(as(values(regions.gr.clean),"data.frame"),hist(p.min, breaks = 10))
@ 
<<transvp3, fig = TRUE, eval = TRUE, echo = TRUE, cache = FALSE>>=
layout(mat=matrix(1:4, nrow = 2, ncol = 2 ))
with(as(values(regions.gr.clean),"data.frame"),plot(trans.median, -log10(p.min), pch = 20))
with(as(values(regions.gr.clean),"data.frame"),plot(n.cmp, -log10(p.min), pch = 20))
with(as(values(regions.gr.clean),"data.frame"),plot(n.cmp, trans.median, pch = 20))
with(as(values(regions.gr.clean),"data.frame"),plot(width(regions.gr.clean), n.cmp, pch = 20))
@ 

== Association (Region-wise) ==
Note that this uses a very strict definition for non-transmitted.  To be non-transmitted a region must have no component in region with a trio-state that indicates non-transmission.  This may bias the estimate towards over-transmission.

First we see how many regions there are to begin with.
<<regions, eval = TRUE>>=
reduce(rowData(fe.beaty))
@

<<trioStates2, eval = TRUE, echo = TRUE, results = verbatim, cache = TRUE>>=
trans.mat <- c()
n.reg <- length(reduce(rowData(fe.beaty)))
system.time(
for( i in 1:n.reg){
# for( i in 1:10){
fe.beaty.i <- fe.beaty[subjectHits(findOverlaps(reduce(rowData(fe.beaty))[i], rowData(fe.beaty)))]
fe.pitt.i <- fe.pitt[subjectHits(findOverlaps(reduce(rowData(fe.pitt))[i], rowData(fe.pitt)))]

if( length(rowData(fe.beaty.i)) > 1 ){
    trioAssay.beaty <- Trioconductor:::TrioAssay(fe.beaty.i, type = "cnv")
    trioStates.beaty <- with(trioAssay.beaty, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.beaty) <- dimnames(trioAssay.beaty$O)
    trioAssay.pitt <- Trioconductor:::TrioAssay(fe.pitt.i, type = "cnv")
    trioStates.pitt <- with(trioAssay.pitt, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.pitt) <- dimnames(trioAssay.pitt$O)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    trans.beaty.logical <- rowSums(matrix(trioStates.beaty %in% c("011","101","111","112","122","212"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    untrans.beaty.logical <- rowSums(matrix(trioStates.beaty %in% c("010","100","111","110","121","211"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    trans.beaty <- sum(trans.beaty.logical)
    untrans.beaty <- sum(untrans.beaty.logical & !trans.beaty.logical)

    trans.pitt.logical <- rowSums(matrix(trioStates.pitt %in% c("011","101","111","112","122","212"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    untrans.pitt.logical <- rowSums(matrix(trioStates.pitt %in% c("010","100","111","110","121","211"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    trans.pitt <- sum(trans.pitt.logical)
    untrans.pitt <- sum(untrans.pitt.logical & !trans.pitt.logical)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    trans.beaty.ma.logical <- rowSums(matrix(trioStates.beaty %in% c("011","112","212"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    untrans.beaty.ma.logical <- rowSums(matrix(trioStates.beaty %in% c("010","110","211"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    trans.beaty.ma <- sum(trans.beaty.ma.logical)
    untrans.beaty.ma <- sum(untrans.beaty.ma.logical & !trans.beaty.ma.logical)

    trans.pitt.ma.logical <- rowSums(matrix(trioStates.pitt %in% c("011","112","212"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    untrans.pitt.ma.logical <- rowSums(matrix(trioStates.pitt %in% c("010","110","211"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    trans.pitt.ma <- sum(trans.pitt.ma.logical)
    untrans.pitt.ma <- sum(untrans.pitt.ma.logical & !trans.pitt.ma.logical)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    trans.beaty.fa.logical <- rowSums(matrix(trioStates.beaty %in% c("101","112","122"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    untrans.beaty.fa.logical <- rowSums(matrix(trioStates.beaty %in% c("100","110","121"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    trans.beaty.fa <- sum(trans.beaty.fa.logical)
    untrans.beaty.fa <- sum(untrans.beaty.fa.logical & !trans.beaty.fa.logical)

    trans.pitt.fa.logical <- rowSums(matrix(trioStates.pitt %in% c("101","112","122"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    untrans.pitt.fa.logical <- rowSums(matrix(trioStates.pitt %in% c("100","110","121"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    trans.pitt.fa <- sum(trans.pitt.fa.logical)
    untrans.pitt.fa <- sum(untrans.pitt.fa.logical & !trans.pitt.fa.logical)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    trans.mat <- rbind( trans.mat, c(trans.beaty, untrans.beaty, trans.pitt, untrans.pitt, trans.beaty.ma, untrans.beaty.ma, trans.beaty.fa, untrans.beaty.fa, trans.pitt.ma, untrans.pitt.ma, trans.pitt.fa, untrans.pitt.fa ) )

}else{
    trioAssay.beaty <- Trioconductor:::TrioAssay(fe.beaty.i, type = "cnv")
    trioStates.beaty <- matrix(with(trioAssay.beaty, paste0(F,M,O)),ncol=1)
    dimnames(trioStates.beaty) <- dimnames(trioAssay.beaty$O)
    trioAssay.pitt <- Trioconductor:::TrioAssay(fe.pitt.i, type = "cnv")
    trioStates.pitt <- matrix(with(trioAssay.pitt, paste0(F,M,O)),ncol=1)
    dimnames(trioStates.pitt) <- dimnames(trioAssay.pitt$O)


    trans.beaty.logical <- rowSums(matrix(trioStates.beaty %in% c("011","101","111","112","122","212"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    untrans.beaty.logical <- rowSums(matrix(trioStates.beaty %in% c("010","100","111","110","121","211"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    trans.beaty <- sum(trans.beaty.logical)
    untrans.beaty <- sum(untrans.beaty.logical & !trans.beaty.logical)

    trans.pitt.logical <- rowSums(matrix(trioStates.pitt %in% c("011","101","111","112","122","212"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    untrans.pitt.logical <- rowSums(matrix(trioStates.pitt %in% c("010","100","111","110","121","211"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    trans.pitt <- sum(trans.pitt.logical)
    untrans.pitt <- sum(untrans.pitt.logical & !trans.pitt.logical)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    trans.beaty.ma.logical <- rowSums(matrix(trioStates.beaty %in% c("011","112","212"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    untrans.beaty.ma.logical <- rowSums(matrix(trioStates.beaty %in% c("010","110","211"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    trans.beaty.ma <- sum(trans.beaty.ma.logical)
    untrans.beaty.ma <- sum(untrans.beaty.ma.logical & !trans.beaty.ma.logical)

    trans.pitt.ma.logical <- rowSums(matrix(trioStates.pitt %in% c("011","112","212"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    untrans.pitt.ma.logical <- rowSums(matrix(trioStates.pitt %in% c("010","110","211"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    trans.pitt.ma <- sum(trans.pitt.ma.logical)
    untrans.pitt.ma <- sum(untrans.pitt.ma.logical & !trans.pitt.ma.logical)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    trans.beaty.fa.logical <- rowSums(matrix(trioStates.beaty %in% c("101","112","122"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    untrans.beaty.fa.logical <- rowSums(matrix(trioStates.beaty %in% c("100","110","121"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    trans.beaty.fa <- sum(trans.beaty.fa.logical)
    untrans.beaty.fa <- sum(untrans.beaty.fa.logical & !trans.beaty.fa.logical)

    trans.pitt.fa.logical <- rowSums(matrix(trioStates.pitt %in% c("101","112","122"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    untrans.pitt.fa.logical <- rowSums(matrix(trioStates.pitt %in% c("100","110","121"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    trans.pitt.fa <- sum(trans.pitt.fa.logical)
    untrans.pitt.fa <- sum(untrans.pitt.fa.logical & !trans.pitt.fa.logical)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    trans.mat <- rbind( trans.mat, c(trans.beaty, untrans.beaty, trans.pitt, untrans.pitt, trans.beaty.ma, untrans.beaty.ma, trans.beaty.fa, untrans.beaty.fa, trans.pitt.ma, untrans.pitt.ma, trans.pitt.fa, untrans.pitt.fa ) )

}
}
)
colnames(trans.mat) <- c("trans.cleft", "untrans.cleft", "trans.con", "untrans.con", "trans.cleft.ma", "untrans.cleft.ma", "trans.cleft.fa", "untrans.cleft.fa", "trans.con.ma", "untrans.con.ma", "trans.con.fa", "untrans.con.fa")
save(trans.mat, file = "./../data/trans.mat.RData")
system("R CMD INSTALL ~/Trioconductor")
source("~/Trioconductor/R/reload.R")
reload("Trioconductor")
@

<<trioStates3, eval = TRUE, echo = TRUE, results = verbatim, cache = TRUE>>=
trans.mat.clp <- c()
gr.reduce <- reduce(rowData(fe.beaty))
n.reg <- length(gr.reduce)
for( i in 1:n.reg){
# for( i in 1:10){
     fe.beaty.i <- fe.beaty[subjectHits(findOverlaps(gr.reduce[i], rowData(fe.beaty)))]
     trioAssay.beaty <- Trioconductor:::TrioAssay(fe.beaty.i, type = "cnv")
     if( length(rowData(fe.beaty.i)) > 1 ){
     	trioStates.beaty <- with(trioAssay.beaty, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
     }else{
	trioStates.beaty <- matrix(with(trioAssay.beaty, paste0(F,M,O)),ncol=1)
     }
	dimnames(trioStates.beaty) <- dimnames(trioAssay.beaty$O)
    trioStates.beaty.clp1 <- trioStates.beaty[colData(fe.beaty.pheno)[rownames(trioStates.beaty),]$clp==1,]
    trioStates.beaty.clp2 <- trioStates.beaty[colData(fe.beaty.pheno)[rownames(trioStates.beaty),]$clp==2,]
    trioStates.beaty.clp3 <- trioStates.beaty[colData(fe.beaty.pheno)[rownames(trioStates.beaty),]$clp==3,]
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    trans.clp1 <- trioStates.beaty.clp1 %in% c("011","101","111","112","122","212")
    untrans.clp1 <- trioStates.beaty.clp1 %in% c("010","100","111","110","121","211")
     
     if( length(trans.clp1 > 0)){
       trans.beaty.logical.clp1 <- rowSums(matrix(trans.clp1, nrow = nrow(trioStates.beaty.clp1), ncol = ncol(trioStates.beaty.clp1), byrow=FALSE)) > 0
     }else{
       trans.beaty.logical.clp1 <- 0
     }
     if( length(untrans.clp1 > 0)){
       untrans.beaty.logical.clp1 <- rowSums(matrix(untrans.clp1, nrow = nrow(trioStates.beaty.clp1), ncol = ncol(trioStates.beaty.clp1), byrow=FALSE)) > 0
     }else{
       untrans.beaty.logical.clp1 <- 0
     }
     
    trans.beaty.clp1 <- sum(trans.beaty.logical.clp1)
    untrans.beaty.clp1 <- sum(untrans.beaty.logical.clp1 & !trans.beaty.logical.clp1)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    trans.clp2 <- trioStates.beaty.clp2 %in% c("011","101","111","112","122","212")
    untrans.clp2 <- trioStates.beaty.clp2 %in% c("010","100","111","110","121","211")
     
     if( length(trans.clp2 > 0)){
       trans.beaty.logical.clp2 <- rowSums(matrix(trans.clp2, nrow = nrow(trioStates.beaty.clp2), ncol = ncol(trioStates.beaty.clp2), byrow=FALSE)) > 0
     }else{
       trans.beaty.logical.clp2 <- 0
     }
     if( length(untrans.clp2 > 0)){
       untrans.beaty.logical.clp2 <- rowSums(matrix(untrans.clp2, nrow = nrow(trioStates.beaty.clp2), ncol = ncol(trioStates.beaty.clp2), byrow=FALSE)) > 0
     }else{
       untrans.beaty.logical.clp2 <- 0
     }
     
    trans.beaty.clp2 <- sum(trans.beaty.logical.clp2)
    untrans.beaty.clp2 <- sum(untrans.beaty.logical.clp2 & !trans.beaty.logical.clp2)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    trans.clp3 <- trioStates.beaty.clp3 %in% c("011","101","111","112","122","212")
    untrans.clp3 <- trioStates.beaty.clp3 %in% c("010","100","111","110","121","211")
     
     if( length(trans.clp3 > 0)){
       trans.beaty.logical.clp3 <- rowSums(matrix(trans.clp3, nrow = nrow(trioStates.beaty.clp3), ncol = ncol(trioStates.beaty.clp3), byrow=FALSE)) > 0
     }else{
       trans.beaty.logical.clp3 <- 0
     }
     if( length(untrans.clp3 > 0)){
       untrans.beaty.logical.clp3 <- rowSums(matrix(untrans.clp3, nrow = nrow(trioStates.beaty.clp3), ncol = ncol(trioStates.beaty.clp3), byrow=FALSE)) > 0
     }else{
       untrans.beaty.logical.clp3 <- 0
     }
     
    trans.beaty.clp3 <- sum(trans.beaty.logical.clp3)
    untrans.beaty.clp3 <- sum(untrans.beaty.logical.clp3 & !trans.beaty.logical.clp3)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    trans.mat.clp <- rbind( trans.mat.clp, c(trans.beaty.clp1, untrans.beaty.clp1, trans.beaty.clp2, untrans.beaty.clp2, trans.beaty.clp3, untrans.beaty.clp3 ) )
#     trans.mat.clp <- rbind( trans.mat.clp, c(trans.beaty.clp1, untrans.beaty.clp1) )
}
colnames(trans.mat.clp) <- c("trans.clp1","untrans.clp1","trans.clp2","untrans.clp2","trans.clp3","untrans.clp3")
save(trans.mat.clp, file = "./../data/trans.mat.clp.RData")
head(trans.mat)
head(trans.mat.clp)
@

<<loadtrans, eval = TRUE, echo = FALSE, cache = FALSE>>=
load(file = "./../data/trans.mat.RData")
@

<<transrate, echo = TRUE, eval = TRUE, cache = FALSE>>=
transrate.cleft <- trans.mat[,"trans.cleft"]/rowSums(trans.mat[,c("trans.cleft","untrans.cleft")])
transrate.con <- trans.mat[,"trans.con"]/rowSums(trans.mat[,c("trans.con","untrans.con")])
transrate.all <- rowSums(trans.mat[,c("trans.cleft","trans.con")])/rowSums(trans.mat[,c("trans.cleft","untrans.cleft","trans.con","untrans.con")])
@
Here we filter out any rare deletions by requiring at least 25 observeable transmissins in the cleft group and the control group.
<<testable, cache = FALSE, results = verbatim, eval = TRUE>>=
TU.mat <- trans.mat
testable <- which(   (rowSums(TU.mat[,1:2])>=25) & (rowSums(TU.mat[,3:4])>=25) )
TU.mat <- TU.mat[testable,]
trans.mat.clp <- trans.mat.clp[testable,]
@
<<testable2, echo = TRUE, eval = TRUE, cache = FALSE>>=
rownames(TU.mat) <- names(table.list.beaty)[testable]
colnames(TU.mat) <- c("T.case", "U.case", "T.con", "U.con", "trans.cleft.ma", "untrans.cleft.ma", "trans.cleft.fa", "untrans.cleft.fa", "trans.con.ma", "untrans.con.ma", "trans.con.fa", "untrans.con.fa")
DF <- DataFrame(reduce(rowData(fe.beaty))[testable],TU.mat, trans.mat.clp)
colnames(DF) <- c("grange", colnames(TU.mat), colnames(trans.mat.clp))
@
First we display the function that performs Fishers exact test.
<<TUfish, eval = TRUE, echo = TRUE, cache = FALSE>>=
Trioconductor:::TU.fish
@
Then we apply it to each region after filtering out regions that did not have enough observations.
<<fish2, eval = TRUE, echo = TRUE, cache = FALSE>>=
TU.mat.test <- TU.mat[,1:4]
colnames(TU.mat.test) <- c("T.case", "U.case", "T.con", "U.con")
fish.list <- apply(TU.mat.test,1,Trioconductor:::TU.fish)
p.vec <- unlist( lapply( fish.list, function(obj) return(obj$p.value) ) )
DF <- DataFrame(DF,p.vec,transrate.all[testable],transrate.con[testable],transrate.cleft[testable])
head(as(DF[with(as(DF,"data.frame"),order(p.vec)),],"data.frame"))
@
There are \Sexpr{nrow(DF)} regions that were tested.  Here we see the first six ordered by p-value and later ordered by transmission rate.
<<headtrans, eval = TRUE, echo = TRUE, cache = FALSE>>=
head(as(DF[with(as(DF,"data.frame"),order(transrate.con.testable.)),],"data.frame"))
@ 

Note that a region on chromosome six appears twice in the top six by p-value.  However we see in the six regions with the lowest transmissin rates that there is a region with extremly low transmission rate nearby.  It seems likely that both the chr15 and chr6 signals are spurious and due to false positives in the controls.

=== Figures ===

<<transhist, fig = TRUE, cache = FALSE,  height=6, width = 6, eval = TRUE, echo = TRUE, results = hide >>=
par(bg="white")
hist(DF$transrate.con.testable., col = "gray", xlab = "Regional Transmission Rate", ylab = "", main = "", xlim = c(0,1) )
@

<<cifigcleft, fig = TRUE, cache = FALSE, echo = TRUE, eval = TRUE>>=
htest.list.cleft <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.cleft[[i]] <- binom.test(TU.mat[i,"T.case"],sum(TU.mat[i,c("T.case","U.case")]))
}
ci.list.cleft <- lapply(htest.list.cleft, Trioconductor:::get.ci)
ci.mat.cleft <- matrix(unlist(ci.list.cleft),nrow = length(htest.list.cleft), ncol = 2, byrow = TRUE )
o <- order(DF$transrate.con.testable.)
plot(1, type = "n", xlim = c(1,nrow(ci.mat.cleft)), ylim = c(0,1), xlab = "Deleted Regions", ylab = "Cleft Transmission Rate", main = "" )
polygon( x = c(x <- 1:nrow(ci.mat.cleft), rev(x)), y = c(ci.mat.cleft[o,1],rev(ci.mat.cleft[o,2])),col = "orange", border = "black")
lines( c(1,nrow(ci.mat.cleft)), rep(0.5,2), lty = 3 )
lines( rep(28,2), c(0,1), lty = 3 )
lines( rep(34,2), c(0,1), lty = 3 )
lines( rep(8,2), c(0,1), lty = 3 )
@
<<cifigcon, fig = TRUE, cache = FALSE, echo = TRUE, eval = TRUE>>=
htest.list.con <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.con[[i]] <- binom.test(TU.mat[i,"T.con"],sum(TU.mat[i,c("T.con","U.con")]))
}
ci.list.con <- lapply(htest.list.con, Trioconductor:::get.ci)
ci.mat.con <- matrix(unlist(ci.list.con),nrow = length(htest.list.con), ncol = 2, byrow = TRUE )
o <- order(DF$transrate.con.testable.)
plot(1, type = "n", xlim = c(1,nrow(ci.mat.con)), ylim = c(0,1), xlab = "Deleted Regions", ylab = "Con Transmission Rate", main = "" )
polygon( x = c(x <- 1:nrow(ci.mat.con), rev(x)), y = c(ci.mat.con[o,1],rev(ci.mat.con[o,2])),col = "blue", border = "black")
lines( c(1,nrow(ci.mat.con)), rep(0.5,2), lty = 3 )
lines( rep(28,2), c(0,1), lty = 3 )
lines( rep(34,2), c(0,1), lty = 3 )
lines( rep(8,2), c(0,1), lty = 3 )
@
<<cifigall, fig = TRUE, cache = FALSE, echo = TRUE, eval = TRUE>>=
htest.list.all <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.all[[i]] <- binom.test(sum(TU.mat[i,c("T.case","T.con")]), sum(TU.mat[i,c("T.case","U.case","T.con","U.con")]))
}
ci.list.all <- lapply(htest.list.all, Trioconductor:::get.ci)
ci.mat.all <- matrix(unlist(ci.list.all),nrow = length(htest.list.all), ncol = 2, byrow = TRUE )
o <- order(DF$transrate.con.testable.)
plot(1, type = "n", xlim = c(1,nrow(ci.mat.all)), ylim = c(0,1), xlab = "Deleted Regions", ylab = "All Transmission Rate", main = "" )
polygon( x = c(x <- 1:nrow(ci.mat.all), rev(x)), y = c(ci.mat.all[o,1],rev(ci.mat.all[o,2])),col = "green", border = "black")
lines( c(1,nrow(ci.mat.all)), rep(0.5,2), lty = 3 )
lines( rep(28,2), c(0,1), lty = 3 )
lines( rep(34,2), c(0,1), lty = 3 )
lines( rep(8,2), c(0,1), lty = 3 )
@
<<chr7ci, eval = TRUE, echo = TRUE, results = hide>>=
as(reduce(rowData(fe.beaty))[testable,],"data.frame")
ci.mat.cleft[25,]
ci.mat.con[25,]
ci.mat.all[25,]
ci.mat.cleft[26,]
ci.mat.con[26,]
ci.mat.all[26,]
ci.mat.cleft[32,]
ci.mat.con[32,]
ci.mat.all[32,]
which(o==25)
which(o==26)
which(o==32)
@
<<cifig1, fig = TRUE, width = 5, height = 5, echo = TRUE, eval = TRUE>>=
eps <- 0.05
plot(1,type = "n", xlim = c(0,1), ylim = c(0,1), xlab = "Transmission Rate", ylab = "", main = "95% Confidence Interval", axes = FALSE)
lines(x = ci.mat.cleft[25,], y = rep(0.75-eps,2), lwd = 2, col = "orange")
lines(x = ci.mat.con[25,], y = rep(0.75,2), lwd = 2, col = "blue")
lines(x = ci.mat.all[25,], y = rep(0.75+eps,2), lwd = 2, col = "green")
lines(x = ci.mat.cleft[26,], y = rep(0.5-eps,2), lwd = 2, col = "orange")
lines(x = ci.mat.con[26,], y = rep(0.5,2), lwd = 2, col = "blue")
lines(x = ci.mat.all[26,], y = rep(0.5+eps,2), lwd = 2, col = "green")
lines(x = ci.mat.cleft[32,], y = rep(0.25-eps,2), lwd = 2, col = "orange")
lines(x = ci.mat.con[32,], y = rep(0.25,2), lwd = 2, col = "blue")
lines(x = ci.mat.all[32,], y = rep(0.25+eps,2), lwd = 2, col = "green")
lines(rep(0.5,2), c(0,1), lty = 3 )
axis(1, at = at <- c(0.25, 0.5, 0.75), labels = at )
text( x = 0.1, y = 0.75, labels = "Chr. 7 (34)" )
text( x = 0.1, y = 0.5, labels = "Chr. 8 (28)" )
text( x = 0.1, y = 0.25, labels = "Chr. 15 (8)" )
legend(x = 0.8, y = 1, legend = c("All","Control", "Cleft"), pch = 19, col = c("green", "blue","orange"), cex = 0.75)
@

=== Tables ===

.Transmission Counts
[width="60%",cols="8"]
[options="header",grid="rows"]
|======
|pos|width|p-value|nearest gene|cleft transmitted|cleft untransmitted|control transmitted|control untransmitted
|link:http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg18&omimGene=full&decipher=full&position=Chr7:141380317-141447476[chr7:141380317-141447476]|67,160|0.003397|link:http://genome.ucsc.edu/cgi-bin/hgGene?hgg_gene=uc003vwy.1&hgg_prot=NP_004659&hgg_chrom=chr7&hgg_start=141342147&hgg_end=141453016&hgg_type=knownGene&db=hg18&hgsid=340436443[MGAM]|69 (0.645)|38|68 (0.466)|78
|link:http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg18&omimGene=full&decipher=full&position=Chr8:39341981-39548228[chr8:39,341,981-39,548,228]|206,248 |0.010868|link:http://genome.ucsc.edu/cgi-bin/hgc?hgsid=340437289&c=chr8&o=39427720&t=39499665&g=refGene&i=NR_073423[ADAM3A], link:http://genome.ucsc.edu/cgi-bin/hgc?hgsid=340437289&c=chr8&o=39291338&t=39379532&g=refGene&i=NR_001448[ADAM5]|140 (0.574)|104|32 (0.416)|45
|link:http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg18&omimGene=full&decipher=full&position=chr15:18474541-20730425[chr15:18,474,541-20,730,425]|2,255,885|0.000644|too many, centromere|54 (0.535)|47|44 (0.319)|94
|======

=== MGAM & ADAM9 ===

.MGAM
[quote, Vincent-Chong et al., PLoS One 2013]
____
This study has identified a novel genomic amplification on chromosome 7q34 which was present in 34 out of 46 OSCC samples. The MGAM gene at this locus was significantly over expressed (6.6 fold) in 29 out of 30 samples analysed. It has been previously suggested that MGAM is a carbohydrate active enzyme that is involved in cell metabolism by breaking down the dietary starches and sugars into glucose [67]. The involvement of this gene in carcinogenesis could be explained by the Warburg effect which implies that during tumor progression, alterations are observed in glucose metabolism including glycolysis and oxidative phosphorylation process in cancer cells [68]. It could be hypothesized that over expression of MGAM may promote tumor growth by altering cell metabolism. Further investigation of this gene is required to elucidate its function, regulation and role in oral carcinogenesis.
____

See link:http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0054705[Vincent-Chong et al.] in Plos One -  "Genome Wide Analysis of Chromosomal Alterations in Oral Squamous Cell Carcinomas Revealed over Expression of MGAM and ADAM9." link:http://www.ncbi.nlm.nih.gov/pubmed/?term=23405089[PMID:23405089]

=== Filter ===

==== HLA Super-Locus ====

Five distinct but nearby regions on chromosome 6 appear between 29,940,311 and 32,788,048 (hg18) with transmission rates of 0.533, 0.450, 0.347, 0.366, 0.320.  The exceptionally low transmission rates for the last three of these regions raised eyebrows and upon inspection of the genomic location we immediately observed that 4 of 5 of these regions contain a gene in the HLA family.  The HLA family of genes are known to be...

// control: 0.533, 0.450, 0.347, 0.366, 0.320
// cleft: 0.546, 0.515, 0.515, 0.505, 0.179

.Chromosome 6 Regions & HLA
[width="60%",cols="4"]
[options="header",grid="rows"]
|======
|UCSC Genome Browser (hg18)|band|Trans. (control)
|link:http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg18&omimGene=full&decipher=full&position=chr6:29940311-30032810[chr6:29940311-30032810]|6p21.33|0.533
|link:http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg18&omimGene=full&decipher=full&position=chr6:31382534-31422222[chr6:31382534-31422222]|6p21.33|0.450
|link:http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg18&omimGene=full&decipher=full&position=chr6:32055573-32124218[chr6:32055573-32124218]|6p21.32|0.347
|link:http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg18&omimGene=full&decipher=full&position=chr6:32536895-32684456[chr6:32536895-32684456]|6p21.32|0.366
|link:http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg18&omimGene=full&decipher=full&position=chr6:32694224-32788048[chr6:32694224-32788048]|6p21.32|0.320
|======

image:figures/HLA.jpg[link="https://en.wikipedia.org/wiki/Human_leukocyte_antigen"]

We choose to remove these due to the unusually high amount of known variability in this region.  We believe the noisy control data, coupled with the highly variable HLA region results in deflated transmission rates in the controls, and therefore testing against the controls will result in false positive detection.

<<filterhla, eval = TRUE>>=
hla.gr <- GRanges(seqname="chr6", range = IRanges(start = 29940311, end =  32788048))
@

==== Centromeres, Telomeres & Low Mapability ====

We also include UCSC centromere/telomere locations and R. Scharpfs list of regions of low-mapability in the filter.

<<filter, eval = TRUE>>=
load(file = "./../data/centromere.RData")
#data("centromere")
lowmap.gr <- readRDS(file = "./../inst/low_mappability.rds")
seqlevels(lowmap.gr) <- seqlevels(DF$grange)
seqlengths(lowmap.gr) <- seqlengths(DF$grange)
filter.gr <- reduce(c(lowmap.gr,centromere.gr,hla.gr))
dist.vec <- as.data.frame(distanceToNearest(DF$grange,filter.gr))$distance
#DF <- DataFrame(DF[order(dist.vec),],dist.vec[order(dist.vec)])
DF <- DataFrame(DF, dist.vec)
as.data.frame(DF)
@

The filter accounts for \Sexpr{round(sum(width(filter.gr))/1e6,0)} MB made up of \Sexpr{length(filter.gr)} distinct regions.

<<filtercmp, echo = TRUE, eval = TRUE>>=
dist.vec.cmp <- as.data.frame(distanceToNearest(DF.cmp$grange,filter.gr))$distance
DF.cmp <- DataFrame(DF.cmp, dist.vec.cmp)
@


<<disthist, fig = TRUE, echo = TRUE, height = 4, width = 4, eval = TRUE>>=
plot(dist.vec[order(dist.vec)]/1e6, type = "b", pch = 20, xlab = "Region", ylab = "Distance to Filtered Region (MB)", main = "", axes = FALSE)
axis(2)
lines(c(1,length(dist.vec)), rep(1,2), lty = 3 )
@

<<disthistpdf, echo = TRUE, results = hide, eval = TRUE>>=
pdf(file = "./figures/disthist.pdf")
par(bg="white")
plot(dist.vec[order(dist.vec)]/1e6, type = "b", pch = 20, xlab = "Region", ylab = "Distance to Filtered Region (MB)", main = "", axes = FALSE)
axis(2)
lines(c(1,length(dist.vec)), rep(1,2), lty = 3 )
dev.off()
@

In the figure above a horizontal line is drawn at 1 MB.  \Sexpr{sum(dist.vec <= 1e6 )} regions are within 1 MB of a bad region, which is \Sexpr{round(sum(dist.vec <= 1e6 )/length(dist.vec)*100,0)}% of all regions! Note that \Sexpr{sum(dist.vec == 0 )} regions overlap a bad region.  In the figure below points in red are within 1 MB of a bad region.

<<disttrans, fig = TRUE, width = 12, height = 6, echo = TRUE, eval = TRUE>>=
plot(DF$dist.vec, DF$transrate.con.testable., pch = 20, col = ifelse(DF$dist.vec<=1e6,"red","black"))
lines(c(0,max(DF$dist.vec)), rep(1/2,2), lty = 3 )
@

<<filterout, fig = TRUE, height = 6, width = 6, echo = TRUE, eval = TRUE>>=
boxplot(list( DF[DF$dist.vec>=1e6,"transrate.con.testable."], DF[DF$dist.vec<1e6,"transrate.con.testable."]), names = c("> 1MB", "< 1MB"), ylab = "Transmission Rate (Controls)" )
@

<<filteroutpdf, echo = TRUE, results = hide, eval = TRUE>>=
pdf(file = "./figures/filterout.pdf")
par(bg="white")
boxplot(list( DF[DF$dist.vec>=1e6,"transrate.con.testable."], DF[DF$dist.vec<1e6,"transrate.con.testable."]), names = c("> 1MB", "< 1MB"), ylab = "Transmission Rate (Controls)" )
dev.off()
@

==== Region-wise ====

<<filteregion, eval = TRUE>>=
TU.mat <- TU.mat[DF$dist.vec > 1e6,]
ci.mat.cleft <- ci.mat.cleft[DF$dist.vec > 1e6,]
ci.mat.con <- ci.mat.con[DF$dist.vec > 1e6,]
DF <- DF[DF$dist.vec > 1e6,]
@

==== Component-wise ====

<<filtercomp, eval = TRUE>>=
TU.mat.cmp <- TU.mat.cmp[DF.cmp$dist.vec > 1e6,]
DF.cmp <- DF.cmp[DF.cmp$dist.vec > 1e6,]
@

=== Chromosome 7 ===

<<gviz, echo = TRUE, eval = TRUE>>=
library("Gviz")
library("TxDb.Hsapiens.UCSC.hg18.knownGene")
txdb <- TxDb.Hsapiens.UCSC.hg18.knownGene
@

<<chr7, fig = TRUE, echo = TRUE, cache = FALSE, width = 12, height = 6, eval = TRUE>>=
chr <- 7
wd <- 100e3
chr7.region <- DF$grange[8]
chr7.index <- subjectHits(findOverlaps(chr7.region,DF.cmp$grange))
chr7.index2 <- subjectHits(findOverlaps(chr7.region,DF.cmp$grange))
gtrack <- GenomeAxisTrack()
grtrack <- GeneRegionTrack(txdb, genome="hg18", chromosome=chr, name="Entrez Gene ID", )
dtrack <- DataTrack( range = DF.cmp$grange[chr7.index], data = t(TU.mat.cmp[chr7.index,]), groups = colnames(TU.mat.cmp), type = "S", cex = 1, name = "Count", ylim = c(0,200), legend = TRUE, col = c(rep("red",2),rep("blue",2)), lty = 1:2, lwd = 2 )
dtrack2 <- DataTrack( range = DF.cmp$grange[chr7.index2], data = -log10(DF.cmp$p.vec[chr7.index2]), type = "S", ylim = c(0,5), name = "-log10(p)", lwd = 2 )
itrack <- IdeogramTrack(genome = "hg18", chromosome = paste0("chr", chr), lty = 1, lwd = 1 )
plotTracks(list(dtrack2, dtrack,  grtrack, gtrack, itrack ),  background.panel = "#FFFEDB", background.title = "darkblue", from = start(chr7.region)-wd, to = end(chr7.region)+wd, collapseTranscripts = TRUE, geneSymbols = FALSE, showId = TRUE, fill = "darkgreen" )
@

<<chr7pdf, echo = TRUE, cache = FALSE, results = hide, eval = TRUE>>=
pdf(file = "./figures/chr7.pdf")
plotTracks(list(dtrack2, dtrack,  grtrack, gtrack, itrack ),  background.panel = "#FFFEDB", background.title = "darkblue", from = start(chr7.region)-wd, to = end(chr7.region)+wd, collapseTranscripts = TRUE, geneSymbols = FALSE, showId = TRUE, fill = "darkgreen" )
dev.off()
@

=== Chromosome 8 ===

<<chr8, fig = TRUE, echo = TRUE, cache = FALSE, width = 12, height = 6, eval = TRUE>>=
chr <- 8
chr8.region <- DF$grange[9]
chr8.index <- subjectHits(findOverlaps(chr8.region,DF.cmp$grange))
chr8.index2 <- subjectHits(findOverlaps(chr8.region,DF.cmp$grange))
gtrack <- GenomeAxisTrack()
grtrack <- GeneRegionTrack(txdb, genome="hg18", chromosome=chr, name="Entrez Gene ID")
dtrack <- DataTrack( range = DF.cmp$grange[chr8.index], data = t(TU.mat.cmp[chr8.index,]), groups = colnames(TU.mat.cmp), type = "S", cex = 1, name = "Count", ylim = c(0,200), legend = TRUE, col = c(rep("red",2),rep("blue",2)), lty = 1:2, lwd = 2 )
dtrack2 <- DataTrack( range = DF.cmp$grange[chr8.index2], data = -log10(DF.cmp$p.vec[chr8.index2]), type = "S", ylim = c(0,5), name = "-log10(p)", lwd = 2 )
itrack <- IdeogramTrack(genome = "hg18", chromosome = paste0("chr", chr), lty = 1, lwd = 1 )
plotTracks(list(dtrack2, dtrack, grtrack, gtrack, itrack ),  background.panel = "#FFFEDB", background.title = "darkblue", from = start(chr8.region)-wd, to = end(chr8.region)+wd, collapseTranscripts = TRUE, geneSymbols = FALSE, showId = TRUE, fill = "darkgreen" )
@

<<chr8pdf, echo = TRUE, cache = FALSE, results = hide, eval = TRUE>>=
pdf(file = "./figures/chr8.pdf")
plotTracks(list(dtrack2, dtrack, grtrack, gtrack, itrack ),  background.panel = "#FFFEDB", background.title = "darkblue", from = start(chr8.region)-wd, to = end(chr8.region)+wd, collapseTranscripts = TRUE, geneSymbols = FALSE, showId = TRUE, fill = "darkgreen" )
dev.off()
@

=== Figure 1 ===

<<cifigcleftnew, fig = TRUE, cache = FALSE, echo = TRUE, results = hide, height = 8, width = 10, eval = TRUE>>=

layout(matrix(1:2,nrow=1,ncol=2))
par(mai=c(1,2.5,0,0), bg = "white")

o <- order(DF$p.vec)
# o <- 1:nrow(ci.mat.cleft)

plot(1, type = "n", ylim = c(1,nrow(ci.mat.cleft)), xlim = c(0,1), ylab = "", xlab = "Transmission Rate", main = "", axes = FALSE, cex.lab = 0.5, cex.axis = 0.5 )

lines( y = c(1,length(o)), x = rep(0.5,2), lty = 3, lwd = 1 )

htest.list.cleft <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.cleft[[i]] <- binom.test(TU.mat[i,"T.case"],sum(TU.mat[i,c("T.case","U.case")]))
}
ci.list.cleft <- lapply(htest.list.cleft, Trioconductor:::get.ci)
ci.mat.cleft <- matrix(unlist(ci.list.cleft),nrow = length(htest.list.cleft), ncol = 2, byrow = TRUE )
eps <- 1/8

for( i in 1:nrow(ci.mat.cleft) ){

     lines( x = c(ci.mat.cleft[o,1][i],ci.mat.cleft[o,2][i]), y = rep(nrow(ci.mat.cleft)-i+1+eps,2), lwd = 2, col = "black")
     points( x = DF$transrate.cleft.testable.[o][i], y = nrow(ci.mat.cleft)-i+1+eps, pch = 19)

}

htest.list.con <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.con[[i]] <- binom.test(TU.mat[i,"T.con"],sum(TU.mat[i,c("T.con","U.con")]))
}
ci.list.con <- lapply(htest.list.con, Trioconductor:::get.ci)
ci.mat.con <- matrix(unlist(ci.list.con),nrow = length(htest.list.con), ncol = 2, byrow = TRUE )

for( i in 1:nrow(ci.mat.con) ){

     lines( x = c(ci.mat.con[o,1][i],ci.mat.con[o,2][i]), y = rep(nrow(ci.mat.con)-i+1-eps,2), lwd = 2, col = "black")
     points( x = DF$transrate.con.testable.[o][i], y = nrow(ci.mat.con)-i+1-eps, pch = 1 )


}

axis(1, at = at <- c(0,0.25,0.5,0.75,1), labels = at )
axis(2, at = at <- (length(o) - 0:(length(o)-1)), labels = paste0(seqnames(DF$grange[o]),":",start(DF$grange[o]),"-",end(DF$grange[o])), las = 2 )

#legend(x = 0.75, y = max(x)-2, legend = c("cleft","control","both"), col = c(rgb(1,0,0,alpha),rgb(0,0,1,alpha),rgb(1,0,1,1)), pch = c(15,15,15), cex = 0.8 )

par(mai=c(1,0,0,0), bg = "white")
plot(-log10(DF$p.vec[o]), y = length(o):1, pch = 20, col = "black", cex = 1.5, axes = FALSE, main = "", xlab = "-log10(p)", ylab = "", xlim = c(0,3), cex.lab = 0.5, cex.axis = 0.5 )
lines(rep(-log10(0.05/sum(DF$dist.vec > 1e6)),2), c(1,length(o)), lty = 3)
lines(rep(-log10(0.05),2), c(1,length(o)), lty = 3)
axis(1)
@

<<cifigcleftnewpdf, cache = FALSE, echo = TRUE>>=
pdf(file = "./figures/cifigcleftnew.pdf", width = 6, height = 4)
par(bg="white")

layout(matrix(1:2,nrow=1,ncol=2))
par(mai=c(1,2.5,0,0)/2, bg = "white", cex = 0.5)

o <- order(DF$p.vec)
# o <- 1:nrow(ci.mat.cleft)

plot(1, type = "n", ylim = c(1,nrow(ci.mat.cleft)+1), xlim = c(0,1), ylab = "", xlab = "Transmission Rate", main = "", axes = FALSE)

lines( y = c(1,length(o)), x = rep(0.5,2), lty = 3, lwd = 1 )

htest.list.cleft <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.cleft[[i]] <- binom.test(TU.mat[i,"T.case"],sum(TU.mat[i,c("T.case","U.case")]))
}
ci.list.cleft <- lapply(htest.list.cleft, Trioconductor:::get.ci)
ci.mat.cleft <- matrix(unlist(ci.list.cleft),nrow = length(htest.list.cleft), ncol = 2, byrow = TRUE )
eps <- 1/8

for( i in 1:nrow(ci.mat.cleft) ){

     lines( x = c(ci.mat.cleft[o,1][i],ci.mat.cleft[o,2][i]), y = rep(nrow(ci.mat.cleft)-i+1+eps,2), lwd = 0.5, col = "black")
     points( x = DF$transrate.cleft.testable.[o][i], y = nrow(ci.mat.cleft)-i+1+eps, pch = 19)

}

htest.list.con <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.con[[i]] <- binom.test(TU.mat[i,"T.con"],sum(TU.mat[i,c("T.con","U.con")]))
}
ci.list.con <- lapply(htest.list.con, Trioconductor:::get.ci)
ci.mat.con <- matrix(unlist(ci.list.con),nrow = length(htest.list.con), ncol = 2, byrow = TRUE )

for( i in 1:nrow(ci.mat.con) ){

     lines( x = c(ci.mat.con[o,1][i],ci.mat.con[o,2][i]), y = rep(nrow(ci.mat.con)-i+1-eps,2), lwd = 0.5, col = "black")
     points( x = DF$transrate.con.testable.[o][i], y = nrow(ci.mat.con)-i+1-eps, pch = 1)


}

axis(1, at = at <- c(0,0.25,0.5,0.75,1), labels = at  )
axis(2, at = at <- (length(o) - 0:(length(o)-1)), labels = paste0(seqnames(DF$grange[o]),":",start(DF$grange[o]),"-",end(DF$grange[o])), las = 2  )

text(x = 0.5, y = length(o)+1, labels = "Transmission (95% CI)\n Cases (solid circles), Controls (open circles)", adj = 0.5)


par(mai=c(1,0,0,0)/2)

plot(-log10(DF$p.vec[o]), y = length(o):1, pch = 20, col = "black" , axes = FALSE, main = "", xlab = "-log10(p)", ylab = "", xlim = c(0,3), ylim = c(1,length(o)+1) )
lines(rep(-log10(0.05/sum(dist.vec > 1e6)),2), c(1,length(o)), lty = 3)
lines(rep(-log10(0.05),2), c(1,length(o)), lty = 3)
axis(1)

text(x = -log10(0.05/sum(dist.vec > 1e6)), y = length(o)+1, labels = "Corrected\n 0.05 significance", adj = 0.5)
text(x = -log10(0.05), y = length(o)+1, labels = "Nominal\n 0.05 significance", adj = 0.5)
@


=== QQ Plot ===

<<ingo, echo = TRUE, eval = TRUE>>=
my.qq.func=function(p,f,pval=TRUE,gc=FALSE,tn,hc=0.99,hm=100,...){
  if(missing(f)) f=rep(0,length(p))
  wh=which(is.na(p)|is.na(f))
  if(length(wh)>0){
    p=p[-wh]
    f=f[-wh]
  }
  wh=order(p)
  p=p[wh]
  f=f[wh]
  if(gc){
    z=qchisq(p,1,lower=F)
    gcp=median(z)/qchisq(0.5,1)
    cat("The genomic control parameter is ",gcp,"\n")
    z=z/gcp
    pchisq(z,1,lower=F)
  }
  n=length(p)
  x1=1:n
  x2=n+1-x1
  x=x1/(n+1)
  up=qbeta(0.975,x1,x2)
  lo=qbeta(0.025,x1,x2)
  if(pval==TRUE){
    uu=up
    up=-log10(lo)
    lo=-log10(uu)
    x=-log10(x)
    z=-log10(p)
  }
  else{
    up=qchisq(up,1)
    lo=qchisq(lo,1)
    x=qchisq(x,1)
    z=qchisq(p,1,lower=F)
  }
  z=rev(z)
  f=rev(f)
  x=rev(x)
  up=rev(up)
  lo=rev(lo)
  tt=NULL
  if(!missing(tn)){
    mx=10^tn
    tt=list(tn=mx,k=rev(x)[mx])
  }
  if(hm>1){
    nc=round(n*hc)
    wh=seq(1,nc,hm)
    wh=c(wh,(nc+1):n)
    z=z[wh]
    f=f[wh]
    x=x[wh]
    up=up[wh]
    lo=lo[wh]
  }
  return(list(z=z,f=f,x=x,up=up,lo=lo,tt=tt))
}

my.qq.plot=function(zz,cut,rmx=0,mt="",mt.cex=1,mt.line=NA,mgp=c(3,1,0),tn.cex=1,plab=T,xr,yr,...){
  if(!missing(cut)) zz$z[zz$z>cut]=cut
  if(missing(xr)) xr=c(0,1.02*max(zz$x))
  if(missing(yr)) yr=c(0,1.02*max(c(zz$up,zz$z,rmx)))
  if(plab){
    xl=expression(paste("expected  ",-log[10]," (p-value)",sep="")) 
    yl=expression(paste("observed  ",-log[10]," (p-value)",sep="")) 
  }
  else{
    xl=""
    yl=""
  }
  par(las=1)
  print(xr)
  plot(range(zz$x),range(c(0,zz$up)),type="n",xlim=xr,ylim=yr,xlab=xl,ylab=yl,...)
  axis(2,0:ceiling(yr)[2],...)
  polygon(c(zz$x,rev(zz$x)),c(zz$lo,rev(zz$up)),col="lightgrey",border=F)
  lines(c(0,max(zz$x)),c(0,max(zz$x)))
  cls=c("blue","red")
  cls=cls[zz$f+1]
  points(zz$x,zz$z,pch=20,col=cls,cex=0.5)
  par(mgp=mgp)
  if(length(zz$tt)==2){
    options(scipen=7)
    axis(3,zz$tt$k,zz$tt$tn,cex.axis=tn.cex)
    options(scipen=0)
  }
  title(mt,cex.main=mt.cex,line=mt.line)
  par(mgp=c(3,1,0))
}

@

<<qqregion, fig = TRUE, width = 6, height = 6, eval = TRUE, echo = TRUE>>=
o <- order(-log10(DF$p.vec), decreasing = TRUE)
plot( -log10((1:length(DF$p.vec))/length(DF$p.vec)), -log10(DF$p.vec)[o], xlim = xlim <- c(0,max(-log10(DF$p.vec))), ylim = xlim, xlab = "Expected -log10p", ylab = "Observed -log10p", main = "")
lines( x = c(0,4), y = c(0,4), lty = 3)
@

<<qqPlotregion, fig = TRUE, width = 6, height = 6, eval = TRUE>>=
library("snpStats")
par(bg="white")
qq.chisq(-2*log(DF$p.vec), df = 2, pch = 20 )

@

<<qqPlotregionpdf, eval = TRUE>>=
pdf(file="figures/qqplotregion.pdf")
par(bg="white")
qq.chisq(-2*log(DF$p.vec), df = 2, pch = 20 )
dev.off()
@

There are \Sexpr{length(DF$p.vec)} tests in this figure.

<<showregion, eval = TRUE>>=
o <- order(DF$p.vec)
as.data.frame(DF[o,])
@

<<qqPlotcmp, fig = TRUE, width = 6, height = 6, eval = TRUE>>=
par(bg="white")
qq.chisq(-2*log(DF.cmp$p.vec), df = 2, pch = 20 )

@

<<qqPlotcmppdf,eval = TRUE>>=
pdf(file="figures/qqplotcmp.pdf")
par(bg="white")
qq.chisq(-2*log(DF.cmp$p.vec), df = 2, pch = 20 )
dev.off()
@

There are \Sexpr{length(DF.cmp$p.vec)} tests in this figure.

<<showcmp, eval = TRUE>>=
o <- order(DF.cmp$p.vec)
as.data.frame(DF.cmp[o,])
@


<<ingoplotreg, echo = TRUE, results = hide, eval = TRUE>>=
zz <- my.qq.func(DF$p.vec,tn=0:4,hc=0.9,hm=1)

pdf("figures/ingo.qq.reg.pdf",width=6,height=6)
xr=c(0,1.02*max(zz$x))
yr=c(0,1.02*max(c(zz$up,zz$z)))
par(las=1,xaxs="i",yaxs="i")
plot(range(zz$x),range(c(0,zz$up)),type="n",xlim=xr,ylim=yr,xlab="",ylab="",xaxt="n")
axis(1,0:4)
axis(3,zz$tt$k,zz$tt$tn,cex.axis=0.5)
  polygon(c(zz$x,rev(zz$x)),c(zz$lo,rev(zz$up)),col="lightgrey",border=F)
lines(c(0,max(zz$x)),c(0,max(zz$x)))
cls=c("blue","red")
cls=cls[zz$f+1]
points(zz$x,zz$z,pch=19,col=cls,cex=0.75)
mtext(expression(paste("expected  ",-log[10]," (p-value)",sep="")),side=1,line=3)
par(las=0)
mtext(expression(paste("observed  ",-log[10]," (p-value)",sep="")),side=2,line=2.5)
dev.off()
@

<<ingoplotcmp, echo = TRUE, results = hide, eval = TRUE>>=
zz <- my.qq.func(DF.cmp$p.vec,tn=0:4,hc=0.9,hm=1)

pdf("figures/ingo.qq.cmp.pdf",width=6,height=6)
xr=c(0,1.02*max(zz$x))
yr=c(0,1.02*max(c(zz$up,zz$z)))
par(las=1,xaxs="i",yaxs="i")
plot(range(zz$x),range(c(0,zz$up)),type="n",xlim=xr,ylim=yr,xlab="",ylab="",xaxt="n")
axis(1,0:4)
axis(3,zz$tt$k,zz$tt$tn,cex.axis=0.5)
  polygon(c(zz$x,rev(zz$x)),c(zz$lo,rev(zz$up)),col="lightgrey",border=F)
lines(c(0,max(zz$x)),c(0,max(zz$x)))
cls=c("blue","red")
cls=cls[zz$f+1]
points(zz$x,zz$z,pch=19,col=cls,cex=0.75)
mtext(expression(paste("expected  ",-log[10]," (p-value)",sep="")),side=1,line=3)
par(las=0)
mtext(expression(paste("observed  ",-log[10]," (p-value)",sep="")),side=2,line=2.5)
dev.off()
@


==== Fisher's Method  ====

===== Component-wise =====

<<fishersmethod, eval = TRUE>>=
(fishers.p.cmp <- sum(-2*log(DF.cmp$p.vec)))
pchisq(fishers.p.cmp, df = 2*length(DF.cmp$p.vec), lower.tail = FALSE)
@

===== Region-wise. =====

<<fishersmethod, eval = TRUE>>=
(fishers.p <- sum(-2*log(DF$p.vec)))
pchisq(fishers.p, df = 2*length(DF$p.vec), lower.tail = FALSE)
@

=== Permutation Test ===

<<perm1, eval = FALSE>>=
index.beaty <- queryHits(findOverlaps(rowData(fe.beaty),DF.cmp$grange))
fe.beaty.2 <- fe.beaty[index.beaty,]

index.pitt <- queryHits(findOverlaps(rowData(fe.pitt),DF.cmp$grange))
fe.pitt.2 <- fe.pitt[index.pitt,]

cD <- DataFrame(colData(fe.beaty.2)$id)
colnames(cD) <- "id"
colData(fe.beaty.2) <- cD
colnames(fe.beaty.2) <- colnames(fe.beaty)

fe.all <- FamilyExperiment( cbind(fe.beaty.2,fe.pitt.2), pedigree = PedClass(rbind(fe.beaty.2@pedigree,fe.pitt.2@pedigree)) )
@

<<perm2, cache = FALSE, eval = FALSE>>=
n.perm <- 1e3			## used to be 1e5
p.mat <- matrix(numeric(n.perm*nrow(fe.all)), ncol = nrow(fe.all), nrow = n.perm )
set.seed(1)
for( i in 1:n.perm ){
     cleft.index <- sample(nrow(completeTrios(fe.all)),nrow(completeTrios(fe.beaty.2)), replace = FALSE )
     cleft.ids <- unique(c(as.matrix(completeTrios(fe.all))[cleft.index,]))
     con.ids   <- unique(c(as.matrix(completeTrios(fe.all))[-cleft.index,]))
     fe.beaty.perm <- fe.all[,colnames(fe.all) %in% cleft.ids]
     fe.pitt.perm <- fe.all[,colnames(fe.all) %in% con.ids]
     trioAssay.beaty <- Trioconductor:::TrioAssay(fe.beaty.perm, type = "cnv")
     trioStates.beaty <- with(trioAssay.beaty, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
     dimnames(trioStates.beaty) <- dimnames(trioAssay.beaty$O)
     trioAssay.pitt <- Trioconductor:::TrioAssay(fe.pitt.perm, type = "cnv")
     trioStates.pitt <- with(trioAssay.pitt, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
     dimnames(trioStates.pitt) <- dimnames(trioAssay.pitt$O)
     table.list.beaty <- apply(trioStates.beaty, 2, "table")
     table.list.pitt <- apply(trioStates.pitt, 2, "table")
     TU.mat.beaty <- matrix(unlist(lapply(table.list.beaty, Trioconductor:::CountTU)), nrow = length(table.list.beaty), ncol = 2, byrow = TRUE )
     TU.mat.pitt <- matrix(unlist(lapply(table.list.pitt, Trioconductor:::CountTU)), nrow = length(table.list.pitt), ncol = 2, byrow = TRUE )
     TU.mat <- cbind(TU.mat.beaty, TU.mat.pitt)
     colnames(TU.mat) <- c("T.case","U.case","T.con","U.con")
     rownames(TU.mat) <- names(table.list.beaty)
     #TU.mat.cmp <- TU.mat
     #gr.cmp <- rowData(fe.beaty.perm)
     fish.list <- apply(TU.mat,1,Trioconductor:::TU.fish)
     p.mat[i,] <- unlist( lapply( fish.list, function(obj) return(obj$p.value) ) )
}
@
These are the adjusted component-wise p-values:
<<pmin, eval = FALSE>>=
p.min <- apply(p.mat,1,"min")
c(chr7=ecdf(p.min)(0.0000983),chr8=ecdf(p.min)(0.0022040))
@
And the threshold for nominal p-values is:
<<padj, eval = FALSE>>=
quantile(p.min,probs=0.05)
@

=== Parent of Origin and Cleft Type Tables ===

.Chromosome 7
[width="40%",cols="5"]
[options="header",grid="rows"]
|======
||T case (clp=1,2,3)| U case| T con|U con|
Total|69 (17,21,31)|38 (13,10,15)|68|78|
Maternal|40|23|35|45|
Paternal|38|19|37|42|
|======

.Chromosome 8
[width="40%",cols="5"]
[options="header",grid="rows"]
|======
||T case (clp=1,2,3)| U case| T con|U con|
Total|140 (46,38,56)|104 (28,33,43)|32|45|
Maternal|86|58|10|17|
Paternal|76|62|21|30|
|======

== Subject IDs for Jeff ==

<<idschr7, eval = FALSE>>=
index <- findOverlaps(rowData(fe.beaty), chr7.region)
fe.beaty.chr7.inherited <- fe.beaty[queryHits(index),rowSums(cnv(fe.beaty[queryHits(index)]))>=1]
(ids.chr7 <- unique(colnames(fe.beaty.chr7.inherited)))
(unique(substr(ids.chr7, start = 1, stop = 5)))
@

<<idschr8, eval = FALSE>>=
chr8.region <- GRanges( seqnames = "chr8", ranges = IRanges( start = 39341981, end = 39548228) )
index <- findOverlaps(rowData(fe.beaty), chr8.region)
fe.beaty.chr8.inherited <- fe.beaty[queryHits(index),rowSums(cnv(fe.beaty[queryHits(index)]))>=1]
(ids.chr8 <- unique(colnames(fe.beaty.chr8.inherited)))
(unique(substr(ids.chr8, start = 1, stop = 5)))
@

== Session Info ==
<<session, echo = TRUE, eval = TRUE, cache = FALSE>>=
date()
sessionInfo()
@

