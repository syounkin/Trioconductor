:toc:
:numbered:
:data-uri:

<<junk,echo=FALSE>>=    Somehow, this avoids the "figure margins too large" error ~kbroman
par(mar=rep(0,4))
@
<<trioClasses, echo = TRUE, eval = TRUE, cache = FALSE>>=
library("trioClasses")
@
== Construct CNV Matrix ==
Before any analysis begins we construct the CNV matrix.  This matrix is a matrix containing 0,1,2 for number of deletions at a CNV component.  Each row corresponds to a subject, and each column to a cnv component.
<<package, echo = TRUE, eval = TRUE, cache = FALSE>>=
library("trioClasses")
source("~/jhsph/R/packages/CleftCNVAssoc/vignettes/curated/make-data.R")
gr.deletion.beaty <- gr.beaty[values(gr.beaty)$numsnp >= 10 & values(gr.beaty)$cn %in% 0:1 ]
homos.beaty <- with(values(gr.deletion.beaty),cn==0)
gr.deletion.pitt <- gr.pitt[values(gr.pitt)$numsnp >= 10 & values(gr.pitt)$cn %in% 0:1 ]
homos.pitt <- with(values(gr.deletion.pitt),cn==0)
gr.deletion.beaty.clean <- c( unlist(reduce(split(gr.deletion.beaty, values(gr.deletion.beaty)$id))), unlist(reduce(split(gr.deletion.beaty[homos.beaty], values(gr.deletion.beaty[homos.beaty])$id))))
gr.deletion.pitt.clean <- c( unlist(reduce(split(gr.deletion.pitt, values(gr.deletion.pitt)$id))), unlist(reduce(split(gr.deletion.pitt[homos.pitt], values(gr.deletion.pitt[homos.pitt])$id))))
@ 
Now with these GRanges objects we use the trioClasses function CNVMatrix to construct the CNV matrices.
<<cnvmatrix, echo = TRUE, eval = TRUE, cache = TRUE>>=
system.time( cnv.obj.beaty <- CNVMatrix( gr.deletion.beaty.clean, gr = gr.deletion.pitt.clean ) )
system.time( cnv.obj.pitt <- CNVMatrix( gr.deletion.pitt.clean, gr = gr.deletion.beaty.clean ) )
save( cnv.obj.beaty, cnv.obj.pitt, file = "./../data/cnv.RData" )
@ 

== Make Data ==
Now we use the CNV matrix as part of a FamilyExperiment object, as defined in trioClasses.  With the FE object we may easily acces trio-states of CNV components and regions.
<<options, echo=TRUE, eval = TRUE >>=
  library("CleftCNVAssoc")
  data("pedigrees", package="CleftCNVAssoc")
#  data("cnv", package = "trioClasses")
@ 
Now we create the FamilyExperiment for the cleft group.
<<se-beaty, echo = FALSE, eval = TRUE>>=
  se.beaty <- SummarizedExperiment(assays = SimpleList(cnv = t(cnv.obj.beaty$cnv.mat)), colData = DataFrame(id=rownames(cnv.obj.beaty$cnv.mat), row.names = rownames(cnv.obj.beaty$cnv.mat)), rowData = cnv.obj.beaty$cmp.gr )
  beaty.trios <- MinimumDistance:::trios(beaty.pedigree)
  beaty.ped <- DataFrame(famid = do.call("rbind",strsplit(beaty.trios$O, "_" ))[,1], id = beaty.trios$O, fid = beaty.trios$F, mid = beaty.trios$M, sex = NA, dx = NA)
  ped <- PedClass(beaty.ped)
  fe.beaty <- FamilyExperiment(se.beaty, pedigree = ped )
@ 
<<fe-beaty, echo = TRUE, eval = TRUE, cache = FALSE>>=
fe.beaty
@
The control group.
<<se-pitt, echo = FALSE, eval = TRUE>>=
  se.pitt <- SummarizedExperiment(assays = SimpleList(cnv = t(cnv.obj.pitt$cnv.mat)), colData = DataFrame(id=rownames(cnv.obj.pitt$cnv.mat), row.names = rownames(cnv.obj.pitt$cnv.mat)), rowData = cnv.obj.pitt$cmp.gr )
  pitt.trios <- MinimumDistance:::trios(pitt.pedigree)
  pitt.ped <- DataFrame(famid = pitt.trios$O, id = pitt.trios$O, fid = pitt.trios$F, mid = pitt.trios$M, sex = NA, dx = NA)
  ped.pitt <- PedClass(pitt.ped)
  fe.pitt <- FamilyExperiment(se.pitt, pedigree = ped.pitt )
@ 
<<fe-pitt, echo = TRUE, eval = TRUE, cache = FALSE>>=
fe.pitt
@
<<save, echo = FALSE, eval = TRUE, cache = FALSE>>=
save(fe.beaty, fe.pitt, file = "./../data/fe.RData" ) 
@ 

== Association (Component-wise) ==
Our first idea was to do a two by two test on the transmitted and non-transmitted counts in clefts and controls.  In the process of doing so we identified regions of under-transmission, as well as a few signifcany regions.
<<options, echo=FALSE, eval = TRUE, echo = FALSE, cache = FALSE>>=
setCacheDir("sgy-cache")
options(width=132, digits=3, scipen=4, continue =" ")
library(trioClasses)
  library("TxDb.Hsapiens.UCSC.hg18.knownGene")
  data("fe", package = "trioClasses")
  data("pedigrees", package="CleftCNVAssoc")
  data("penncnvjoint", package = "CleftCNVAssoc")
  data("cnv", package = "trioClasses")
@ 

<<FamilyExperiment, echo = FALSE, eval = TRUE, cache = FALSE>>=
  fe.beaty.parents <- fe.beaty[,colnames(fe.beaty)%in%parents(fe.beaty)]
  fe.pitt.parents <- fe.pitt[,colnames(fe.pitt)%in%parents(fe.pitt)]
@ 
<<freq-vec, echo = FALSE, eval = TRUE, cache = FALSE>>=
    freq.beaty.vec <- colSums(cnv(fe.beaty.parents))/nrow(cnv(fe.beaty.parents))
    freq.pitt.vec <- colSums(cnv(fe.pitt.parents))/nrow(cnv(fe.pitt.parents))
@ 
// The above must have been written before the MAF method was implemented.
<<trioStates, eval = TRUE, echo = FALSE, cache = TRUE>>=
    trioAssay.beaty <- trioClasses:::TrioAssay(fe.beaty, type = "cnv")
    trioStates.beaty <- with(trioAssay.beaty, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.beaty) <- dimnames(trioAssay.beaty$O)
    trioAssay.pitt <- trioClasses:::TrioAssay(fe.pitt, type = "cnv")
    trioStates.pitt <- with(trioAssay.pitt, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.pitt) <- dimnames(trioAssay.pitt$O)
@ 
<<table-list, eval = TRUE, echo = FALSE, cache = TRUE>>=
    table.list.beaty <- apply(trioStates.beaty, 2, "table")
    table.list.pitt <- apply(trioStates.pitt, 2, "table")
@ 
Compute a DataFrame containing counts of transmissions by case/control with rows for components.  This is partly what distinguishes a DataFrame from a data.frame --- the ability to keep a GRanges object in a column.
<<TU, eval = TRUE, echo = TRUE, cache = FALSE>>=
TU.mat.beaty <- matrix(unlist(lapply(table.list.beaty, trioClasses:::CountTU)), nrow = length(table.list.beaty), ncol = 2, byrow = TRUE )
TU.mat.pitt <- matrix(unlist(lapply(table.list.pitt, trioClasses:::CountTU)), nrow = length(table.list.pitt), ncol = 2, byrow = TRUE )
TU.mat <- cbind(TU.mat.beaty, TU.mat.pitt)
testable <- which(   (rowSums(TU.mat[,1:2])>=25) & (rowSums(TU.mat[,3:4])>=25) )
TU.mat <- TU.mat[testable,]
rownames(TU.mat) <- names(table.list.beaty)[testable]
colnames(TU.mat) <- c("T.case","U.case","T.con","U.con")
DF <- DataFrame(rowData(fe.beaty)[testable],TU.mat)
colnames(DF) <- c("grange", colnames(TU.mat))
@ 
Now with that DataFrame we construct a histogram of overall transmission rate by component.
<<hist, fig = TRUE, eval = TRUE, echo = TRUE, cache = FALSE>>=
hist(trans.vec <- rowSums(TU.mat[,c(1,3)])/rowSums(TU.mat), breaks = 20)
@ 
Histogram of transmission rate component-wise.  We see a clear bimodal distribution.
<<fish, eval = TRUE, echo = FALSE, cache = FALSE>>=
fish.list <- apply(TU.mat,1,trioClasses:::TU.fish)
p.vec <- unlist( lapply( fish.list, function(obj) return(obj$p.value) ) )
(DF <- DataFrame(DF,p.vec, trans.vec))
@ 
Number of components and number of regions is given below.
<<length1, echo = TRUE, eval = TRUE, cache = FALSE>>=
c(length(DF$grange),length(reduce(DF$grange)))
@ 
<<qqplot, fig = TRUE, eval = TRUE, echo = FALSE, cache = FALSE>>=
n <- nrow(DF)
plot( -log10((1:n)/n), -log10(DF$p.vec[order(DF$p.vec)]), xlim = xlim <- c(0,5), ylim = xlim)
lines( c(0,xlim[2]), c(0,xlim[2]), lty = 3 )
@ 


<<pmin, eval = TRUE, echo = FALSE, cache = TRUE>>=
regions.gr <- reduce(DF$grange)
index.vec <- subjectHits(findOverlaps(DF$grange,regions.gr))
DF.list <- split(DF, index.vec)
p.min.DF <- trioClasses:::f.cmp( DF, "p.vec", min, na.rm = TRUE )
n.DF <- trioClasses:::f.cmp( DF, "p.vec", function(vec){sum(!is.na(vec), na.rm = TRUE)})
p.median.DF <- trioClasses:::f.cmp( DF, "p.vec", median, na.rm = TRUE )
trans.median.DF <- trioClasses:::f.cmp( DF, "trans.vec", median, na.rm = TRUE )
@

<<meta, eval = TRUE, echo = FALSE, cache = FALSE>>=
meta <- values(regions.gr)
meta <- DataFrame(meta, p.min = p.min.DF$value, p.median = p.median.DF$value, trans.median = trans.median.DF$value, n.cmp = n.DF$value)
values(regions.gr) <- meta
@
<<tophits, eval = TRUE, echo = FALSE, cache = FALSE>>=
head(as(regions.gr[order(values(regions.gr)$p.min)],"data.frame"),25)
@ 
<<transvp, fig = TRUE, eval = TRUE, echo = FALSE, cache = FALSE>>=
layout(mat=matrix(1:4, nrow = 2, ncol = 2 ))
with(as(values(regions.gr),"data.frame"),plot(trans.median, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, trans.median, pch = 20))
with(as(values(regions.gr),"data.frame"),plot(width(regions.gr)/1e3, n.cmp, pch = 20))
@ 
<<chr16, eval = TRUE, echo = FALSE, cache = FALSE>>=
(bad.region.gr <- regions.gr[which(values(regions.gr)$n.cmp >= 120)])
@ 
The outlier is on chromsome 16.  It is a region with \Sexpr{values(bad.region.gr)$n.cmp} components, and has width \Sexpr{width(bad.region.gr)/1e3} kB. chr16:\Sexpr{start(bad.region.gr)}-\Sexpr{end(bad.region.gr)}.  

<<transvp2, fig = TRUE, eval = FALSE, echo = FALSE, cache = FALSE>>=
regions.gr <- regions.gr[-which(values(regions.gr)$n.cmp >= 120)]
layout(mat=matrix(1:4, nrow = 2, ncol = 2 ))
with(as(values(regions.gr),"data.frame"),plot(trans.median, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, trans.median, pch = 20))
with(as(values(regions.gr),"data.frame"),plot(width(regions.gr), n.cmp, pch = 20))
@ 
<<cumsum, fig = TRUE, width = 8, eval = TRUE, echo = FALSE, cache = FALSE>>=
TranscriptDb <- TxDb.Hsapiens.UCSC.hg18.knownGene
chrlength <- c(0,seqlengths(TranscriptDb)[paste0("chr",1:22)])
names(chrlength) <- c(names(chrlength[-1]),"foo")
chrlength <- rev(rev(chrlength)[-1])
chrstart <- cumsum(chrlength)

plot(1, type = "n", xlim = c(1,3e9), ylim = c(0,6 ), axes = FALSE, xlab = "", ylab = "" )
for( i in 1:length(regions.gr) ){
  points( chrstart[as(seqnames(regions.gr[i]),"character")] + start(DF.list[[i]]$grange), -log10(DF.list[[i]]$p.vec), pch = 20, col = i)
}
axis(1, chrstart, label = paste0("chr",1:length(chrstart)))
axis(2)
@ 
<<transmedianhist, fig = TRUE, eval = TRUE, echo = FALSE, cache = FALSE>>=
with(as(values(regions.gr),"data.frame"),hist(trans.median))
@ 
<<thresh, echo = FALSE, cache = FALSE>>=
thresh <- with(as(values(regions.gr),"data.frame"),median(trans.median))
regions.gr.clean <- regions.gr[which(values(regions.gr)$trans.median >= thresh)]
DF.clean <- DF[queryHits(findOverlaps(DF$grange, regions.gr.clean)),]

@ 
<<qqplot-clean, fig = TRUE, eval = TRUE, echo = FALSE, cache = FALSE>>=
n <- nrow(DF.clean)
plot( -log10((1:n)/n), -log10(DF.clean$p.vec[order(DF.clean$p.vec)]), xlim = xlim <- c(0,5), ylim = xlim)
lines( c(0,xlim[2]), c(0,xlim[2]), lty = 3 )
@ 
<<cumsum2, fig = TRUE, width = 8, eval = TRUE, echo = FALSE, cache = FALSE>>=
index.vec <- subjectHits(findOverlaps(DF.clean$grange,regions.gr.clean))
DF.clean.list <- split(DF.clean, index.vec)

plot(1, type = "n", xlim = c(1,3e9), ylim = c(0,6 ), axes = FALSE, xlab = "", ylab = "" )
for( i in 1:length(regions.gr.clean) ){
  points( chrstart[as(seqnames(regions.gr.clean[i]),"character")] + start(DF.clean.list[[i]]$grange), -log10(DF.clean.list[[i]]$p.vec), pch = 20, col = i)
}
lines( c(1,(chrstart+chrlength)[22]), rep(-log10(0.05/n),2), lty = 3)
axis(1, chrstart, label = paste0("chr",1:length(chrstart)))
axis(2)
@ 
<<phist, fig = TRUE,  eval = FALSE, echo = FALSE, cache = FALSE>>=
with(as(values(regions.gr.clean),"data.frame"),hist(p.min, breaks = 10))
@ 
<<transvp3, fig = TRUE, eval = FALSE, echo = FALSE, cache = FALSE>>=
layout(mat=matrix(1:4, nrow = 2, ncol = 2 ))
with(as(values(regions.gr.clean),"data.frame"),plot(trans.median, -log10(p.min), pch = 20))
with(as(values(regions.gr.clean),"data.frame"),plot(n.cmp, -log10(p.min), pch = 20))
with(as(values(regions.gr.clean),"data.frame"),plot(n.cmp, trans.median, pch = 20))
with(as(values(regions.gr.clean),"data.frame"),plot(width(regions.gr.clean), n.cmp, pch = 20))
@ 

== Association (Region-wise) ==
Note that this uses a very strict definition for non-transmitted.  To be non-transmitted a region must have no component in region with a trio-state that indicates non-transmission.  This may bias the estimate towards over-transmission.

First we see how many regions there are to begin with.
<<regions>>=
reduce(rowData(fe.beaty))
@
But many of these are rare.  Later we filter out the rare regions.
<<trioStates2, eval = TRUE, echo = FALSE, results = verbatim, cache = TRUE>>=
trans.mat <- c()
n.reg <- length(reduce(rowData(fe.beaty)))
system.time(
for( i in 1:n.reg){
fe.beaty.i <- fe.beaty[subjectHits(findOverlaps(reduce(rowData(fe.beaty))[i], rowData(fe.beaty)))]
fe.pitt.i <- fe.pitt[subjectHits(findOverlaps(reduce(rowData(fe.pitt))[i], rowData(fe.pitt)))]

if( length(rowData(fe.beaty.i)) > 1 ){
    trioAssay.beaty <- trioClasses:::TrioAssay(fe.beaty.i, type = "cnv")
    trioStates.beaty <- with(trioAssay.beaty, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.beaty) <- dimnames(trioAssay.beaty$O)
    trioAssay.pitt <- trioClasses:::TrioAssay(fe.pitt.i, type = "cnv")
    trioStates.pitt <- with(trioAssay.pitt, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.pitt) <- dimnames(trioAssay.pitt$O)
    trans.beaty.logical <- rowSums(matrix(trioStates.beaty %in% c("011","101","111","112","122","212"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    untrans.beaty.logical <- rowSums(matrix(trioStates.beaty %in% c("010","100","111","110","121","211"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    trans.beaty <- sum(trans.beaty.logical)
    untrans.beaty <- sum(untrans.beaty.logical & !trans.beaty.logical)
    trans.pitt.logical <- rowSums(matrix(trioStates.pitt %in% c("011","101","111","112","122","212"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    untrans.pitt.logical <- rowSums(matrix(trioStates.pitt %in% c("010","100","111","110","121","211"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    trans.pitt <- sum(trans.pitt.logical)
    untrans.pitt <- sum(untrans.pitt.logical & !trans.pitt.logical)
    trans.mat <- rbind( trans.mat, c(trans.beaty, untrans.beaty, trans.pitt, untrans.pitt) )
}else{
    trioAssay.beaty <- trioClasses:::TrioAssay(fe.beaty.i, type = "cnv")
    trioStates.beaty <- matrix(with(trioAssay.beaty, paste0(F,M,O)),ncol=1)
    dimnames(trioStates.beaty) <- dimnames(trioAssay.beaty$O)
    trans.beaty.logical <- rowSums(matrix(trioStates.beaty %in% c("011","101","111","112","122","212"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    untrans.beaty.logical <- rowSums(matrix(trioStates.beaty %in% c("010","100","111","110","121","211"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0
    trans.beaty <- sum(trans.beaty.logical)
    untrans.beaty <- sum(untrans.beaty.logical & !trans.beaty.logical)
    trioAssay.pitt <- trioClasses:::TrioAssay(fe.pitt.i, type = "cnv")
    trioStates.pitt <- matrix(with(trioAssay.pitt, paste0(F,M,O)),ncol=1)
    dimnames(trioStates.pitt) <- dimnames(trioAssay.pitt$O)
    trans.pitt.logical <- rowSums(matrix(trioStates.pitt %in% c("011","101","111","112","122","212"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    untrans.pitt.logical <- rowSums(matrix(trioStates.pitt %in% c("010","100","111","110","121","211"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0
    trans.pitt <- sum(trans.pitt.logical)
    untrans.pitt <- sum(untrans.pitt.logical & !trans.pitt.logical)
    trans.mat <- rbind( trans.mat, c(trans.beaty, untrans.beaty, trans.pitt, untrans.pitt) )
}
}
)
colnames(trans.mat) <- c("trans.cleft","untrans.cleft", "trans.con","untrans.con")
save(trans.mat, file = "./../data/trans.mat.RData")
@
Note that we exclude any region made up of only on component.
<<loadtrans, eval = FALSE, echo = FALSE, cache = FALSE>>=
load(file = "./../data/trans.mat.RData")
@
<<transrate, echo = FALSE, eval = TRUE, cache = FALSE>>=
transrate.cleft <- trans.mat[,"trans.cleft"]/rowSums(trans.mat[,c("trans.cleft","untrans.cleft")])
transrate.con <- trans.mat[,"trans.con"]/rowSums(trans.mat[,c("trans.con","untrans.con")])
transrate.all <- rowSums(trans.mat[,c("trans.cleft","trans.con")])/rowSums(trans.mat[,c("trans.cleft","untrans.cleft","trans.con","untrans.con")])
@
<<testable, cache = FALSE, results = verbatim>>=
TU.mat <- trans.mat
testable <- which(   (rowSums(TU.mat[,1:2])>=25) & (rowSums(TU.mat[,3:4])>=25) )
TU.mat <- TU.mat[testable,]
@
<<testable2, echo = FALSE, eval = TRUE, cache = FALSE>>=
rownames(TU.mat) <- names(table.list.beaty)[testable]
colnames(TU.mat) <- c("T.case","U.case","T.con","U.con")
DF <- DataFrame(reduce(rowData(fe.beaty))[testable],TU.mat)
colnames(DF) <- c("grange", colnames(TU.mat))
@
<<TUfish, eval = TRUE, echo = TRUE, cache = FALSE>>=
trioClasses:::TU.fish
@
<<fish2, eval = TRUE, echo = TRUE, cache = FALSE>>=
fish.list <- apply(TU.mat,1,trioClasses:::TU.fish)
p.vec <- unlist( lapply( fish.list, function(obj) return(obj$p.value) ) )
DF <- DataFrame(DF,p.vec,transrate.all[testable])
head(as(DF[with(as(DF,"data.frame"),order(p.vec)),],"data.frame"))
@
<<headtrans, eval = TRUE, echo = TRUE, cache = FALSE>>=
nrow(DF)
head(as(DF[with(as(DF,"data.frame"),order(transrate.all.testable.)),],"data.frame"))
@ 
<<transhist, fig = TRUE, cache = FALSE,  height=6, width = 6, eval = TRUE>>=
hist(DF$transrate.all.testable.)
@
<<cifigcleft, fig = TRUE, cache = FALSE, echo = FALSE>>=
htest.list.cleft <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.cleft[[i]] <- binom.test(TU.mat[i,"T.case"],sum(TU.mat[i,c("T.case","U.case")]))
}
ci.list.cleft <- lapply(htest.list.cleft, trioClasses:::get.ci)
ci.mat.cleft <- matrix(unlist(ci.list.cleft),nrow = length(htest.list.cleft), ncol = 2, byrow = TRUE )
o <- order(DF$transrate.all.testable.)
plot(1, type = "n", xlim = c(1,nrow(ci.mat.cleft)), ylim = c(0,1), xlab = "Deleted Regions", ylab = "Cleft Transmission Rate", main = "" )
polygon( x = c(x <- 1:nrow(ci.mat.cleft), rev(x)), y = c(ci.mat.cleft[o,1],rev(ci.mat.cleft[o,2])),col = "orange", border = "black")
lines( c(1,nrow(ci.mat.cleft)), rep(0.5,2), lty = 3 )
lines( rep(28,2), c(0,1), lty = 3 )
lines( rep(34,2), c(0,1), lty = 3 )
@
<<cifigcon, fig = TRUE, cache = FALSE, echo = FALSE>>=
htest.list.con <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.con[[i]] <- binom.test(TU.mat[i,"T.con"],sum(TU.mat[i,c("T.con","U.con")]))
}
ci.list.con <- lapply(htest.list.con, trioClasses:::get.ci)
ci.mat.con <- matrix(unlist(ci.list.con),nrow = length(htest.list.con), ncol = 2, byrow = TRUE )
o <- order(DF$transrate.all.testable.)
plot(1, type = "n", xlim = c(1,nrow(ci.mat.con)), ylim = c(0,1), xlab = "Deleted Regions", ylab = "Con Transmission Rate", main = "" )
polygon( x = c(x <- 1:nrow(ci.mat.con), rev(x)), y = c(ci.mat.con[o,1],rev(ci.mat.con[o,2])),col = "blue", border = "black")
lines( c(1,nrow(ci.mat.con)), rep(0.5,2), lty = 3 )
lines( rep(28,2), c(0,1), lty = 3 )
lines( rep(34,2), c(0,1), lty = 3 )
@
<<cifigall, fig = TRUE, cache = FALSE, echo = FALSE>>=
htest.list.all <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.all[[i]] <- binom.test(sum(TU.mat[i,c("T.case","T.con")]), sum(TU.mat[i,c("T.case","U.case","T.con","U.con")]))
}
ci.list.all <- lapply(htest.list.all, trioClasses:::get.ci)
ci.mat.all <- matrix(unlist(ci.list.all),nrow = length(htest.list.all), ncol = 2, byrow = TRUE )
o <- order(DF$transrate.all.testable.)
plot(1, type = "n", xlim = c(1,nrow(ci.mat.all)), ylim = c(0,1), xlab = "Deleted Regions", ylab = "All Transmission Rate", main = "" )
polygon( x = c(x <- 1:nrow(ci.mat.all), rev(x)), y = c(ci.mat.all[o,1],rev(ci.mat.all[o,2])),col = "green", border = "black")
lines( c(1,nrow(ci.mat.all)), rep(0.5,2), lty = 3 )
lines( rep(28,2), c(0,1), lty = 3 )
lines( rep(34,2), c(0,1), lty = 3 )
@
.How do we filter regions that are undertransmitted?
* Any region whose overall transmission rate CI does not cover 0.5
Foobar!

<<chr7ci, eval = TRUE, echo = TRUE>>=
as(reduce(rowData(fe.beaty))[testable,],"data.frame")
ci.mat.cleft[25,]
ci.mat.con[25,]
ci.mat.all[25,]
ci.mat.cleft[26,]
ci.mat.con[26,]
ci.mat.all[26,]
which(o==25)
which(o==26)
@

== Session Info ==
<<session, echo = TRUE, eval = TRUE, cache = FALSE>>=
sessionInfo()
@
