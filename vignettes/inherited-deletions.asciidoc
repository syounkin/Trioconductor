:toc:
:numbered:
:data-uri:

<<junk,echo=FALSE>>=    Somehow, this avoids the "figure margins too large" error ~kbroman
par(mar=rep(0,4))
@
== Association ==
<<options, echo=FALSE, eval = TRUE, echo = FALSE, cache = FALSE>>=
setCacheDir("sgy-cache")
options(width=132, digits=3, scipen=4, continue =" ")
library(trioClasses)
#library("Gviz")
  library("TxDb.Hsapiens.UCSC.hg18.knownGene")
##  data("fe-25", package = "trioClasses")
  data("fe", package = "trioClasses")
  data("pedigrees", package="CleftCNVAssoc")
  data("penncnvjoint", package = "CleftCNVAssoc")
  data("cnv", package = "trioClasses")
##data("cnv-25", package = "trioClasses")
@ 

<<FamilyExperiment, echo = FALSE, eval = TRUE, cache = TRUE>>=
  fe.beaty.parents <- fe.beaty[,colnames(fe.beaty)%in%parents(fe.beaty)]
  fe.pitt.parents <- fe.pitt[,colnames(fe.pitt)%in%parents(fe.pitt)]
@ 
<<freq-vec, echo = FALSE, eval = TRUE, cache = TRUE>>=
    freq.beaty.vec <- colSums(cnv(fe.beaty.parents))/nrow(cnv(fe.beaty.parents))
    freq.pitt.vec <- colSums(cnv(fe.pitt.parents))/nrow(cnv(fe.pitt.parents))
@ 
// The above must have been written before the MAF method was implemented.
<<trioStates, eval = TRUE, echo = FALSE, cache = TRUE>>=
    trioAssay.beaty <- trioClasses:::TrioAssay(fe.beaty, type = "cnv")
    trioStates.beaty <- with(trioAssay.beaty, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.beaty) <- dimnames(trioAssay.beaty$O)
    trioAssay.pitt <- trioClasses:::TrioAssay(fe.pitt, type = "cnv")
    trioStates.pitt <- with(trioAssay.pitt, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.pitt) <- dimnames(trioAssay.pitt$O)
@ 
<<table-list, eval = TRUE, echo = FALSE, cache = TRUE>>=
    table.list.beaty <- apply(trioStates.beaty, 2, "table")
    table.list.pitt <- apply(trioStates.pitt, 2, "table")
@ 
Compute a DataFrame containing counts of transmissions by case/control with rows for components.  This is partly what distinguishes a DataFrame from a data.frame --- the ability to keep a GRanges object in a column.
<<TU, eval = TRUE, echo = TRUE, cache = TRUE>>=
TU.mat.beaty <- matrix(unlist(lapply(table.list.beaty, trioClasses:::CountTU)), nrow = length(table.list.beaty), ncol = 2, byrow = TRUE )
TU.mat.pitt <- matrix(unlist(lapply(table.list.pitt, trioClasses:::CountTU)), nrow = length(table.list.pitt), ncol = 2, byrow = TRUE )
TU.mat <- cbind(TU.mat.beaty, TU.mat.pitt)
testable <- which(   (rowSums(TU.mat[,1:2])>=25) & (rowSums(TU.mat[,3:4])>=25) )
TU.mat <- TU.mat[testable,]
rownames(TU.mat) <- names(table.list.beaty)[testable]
colnames(TU.mat) <- c("T.case","U.case","T.con","U.con")
DF <- DataFrame(rowData(fe.beaty)[testable],TU.mat)
colnames(DF) <- c("grange", colnames(TU.mat))
@ 
Now with that DataFrame we construct a histogram of overall transmission rate by component.
<<hist, fig = TRUE, eval = TRUE, echo = TRUE, cache = FALSE>>=
hist(trans.vec <- rowSums(TU.mat[,c(1,3)])/rowSums(TU.mat), breaks = 20)
@ 
Histogram of transmission rate component-wise.  We see a clear bimodal distribution.
<<fish, eval = TRUE, echo = FALSE, cache = TRUE>>=
fish.list <- apply(TU.mat,1,trioClasses:::TU.fish)
p.vec <- unlist( lapply( fish.list, function(obj) return(obj$p.value) ) )
(DF <- DataFrame(DF,p.vec, trans.vec))
@ 
Number of components and number of regions is given below.
<<length1, cache = TRUE>>=
c(length(DF$grange),length(reduce(DF$grange)))
@ 
<<qqplot, fig = TRUE, eval = TRUE, echo = FALSE, cache = FALSE>>=
n <- nrow(DF)
plot( -log10((1:n)/n), -log10(DF$p.vec[order(DF$p.vec)]), xlim = xlim <- c(0,5), ylim = xlim)
lines( c(0,xlim[2]), c(0,xlim[2]), lty = 3 )
@ 


<<pmin, eval = TRUE, echo = FALSE, cache = TRUE>>=
regions.gr <- reduce(DF$grange)
index.vec <- subjectHits(findOverlaps(DF$grange,regions.gr))
DF.list <- split(DF, index.vec)
p.min.DF <- trioClasses:::f.cmp( DF, "p.vec", min, na.rm = TRUE )
n.DF <- trioClasses:::f.cmp( DF, "p.vec", function(vec){sum(!is.na(vec), na.rm = TRUE)})
p.median.DF <- trioClasses:::f.cmp( DF, "p.vec", median, na.rm = TRUE )
trans.median.DF <- trioClasses:::f.cmp( DF, "trans.vec", median, na.rm = TRUE )
@

<<meta, eval = TRUE, echo = FALSE, cache = TRUE>>=
meta <- values(regions.gr)
meta <- DataFrame(meta, p.min = p.min.DF$value, p.median = p.median.DF$value, trans.median = trans.median.DF$value, n.cmp = n.DF$value)
values(regions.gr) <- meta
@
<<tophits, eval = TRUE, echo = FALSE, cache = TRUE>>=
head(as(regions.gr[order(values(regions.gr)$p.min)],"data.frame"),25)
@ 
<<transvp, fig = TRUE, eval = TRUE, echo = FALSE, cache = FALSE>>=
layout(mat=matrix(1:4, nrow = 2, ncol = 2 ))
with(as(values(regions.gr),"data.frame"),plot(trans.median, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, trans.median, pch = 20))
with(as(values(regions.gr),"data.frame"),plot(width(regions.gr)/1e3, n.cmp, pch = 20))
@ 
<<chr16, eval = TRUE, echo = FALSE, cache = TRUE>>=
(bad.region.gr <- regions.gr[which(values(regions.gr)$n.cmp >= 120)])
@ 
The outlier is on chromsome 16.  It is a region with \Sexpr{values(bad.region.gr)$n.cmp} components, and has width \Sexpr{width(bad.region.gr)/1e3} kB. chr16:\Sexpr{start(bad.region.gr)}-\Sexpr{end(bad.region.gr)}.  

<<transvp2, fig = TRUE, eval = FALSE, echo = FALSE, cache = FALSE>>=
regions.gr <- regions.gr[-which(values(regions.gr)$n.cmp >= 120)]
layout(mat=matrix(1:4, nrow = 2, ncol = 2 ))
with(as(values(regions.gr),"data.frame"),plot(trans.median, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, -log10(p.min), pch = 20))
with(as(values(regions.gr),"data.frame"),plot(n.cmp, trans.median, pch = 20))
with(as(values(regions.gr),"data.frame"),plot(width(regions.gr), n.cmp, pch = 20))
@ 
<<cumsum, fig = TRUE, width = 8, eval = TRUE, echo = FALSE, cache = FALSE>>=
TranscriptDb <- TxDb.Hsapiens.UCSC.hg18.knownGene
chrlength <- c(0,seqlengths(TranscriptDb)[paste0("chr",1:22)])
names(chrlength) <- c(names(chrlength[-1]),"foo")
chrlength <- rev(rev(chrlength)[-1])
chrstart <- cumsum(chrlength)

plot(1, type = "n", xlim = c(1,3e9), ylim = c(0,6 ), axes = FALSE, xlab = "", ylab = "" )
for( i in 1:length(regions.gr) ){
  points( chrstart[as(seqnames(regions.gr[i]),"character")] + start(DF.list[[i]]$grange), -log10(DF.list[[i]]$p.vec), pch = 20, col = i)
}
axis(1, chrstart, label = paste0("chr",1:length(chrstart)))
axis(2)
@ 
<<transmedianhist, fig = TRUE, eval = TRUE, echo = FALSE, cache = FALSE>>=
with(as(values(regions.gr),"data.frame"),hist(trans.median))
@ 
<<thresh, echo = FALSE, cache = TRUE>>=
thresh <- with(as(values(regions.gr),"data.frame"),median(trans.median))
regions.gr.clean <- regions.gr[which(values(regions.gr)$trans.median >= thresh)]
DF.clean <- DF[queryHits(findOverlaps(DF$grange, regions.gr.clean)),]

@ 
<<qqplot-clean, fig = TRUE, eval = TRUE, echo = FALSE, cache = FALSE>>=
n <- nrow(DF.clean)
plot( -log10((1:n)/n), -log10(DF.clean$p.vec[order(DF.clean$p.vec)]), xlim = xlim <- c(0,5), ylim = xlim)
lines( c(0,xlim[2]), c(0,xlim[2]), lty = 3 )
@ 
<<cumsum2, fig = TRUE, width = 8, eval = TRUE, echo = FALSE, cache = FALSE>>=
#TranscriptDb <- TxDb.Hsapiens.UCSC.hg18.knownGene
#chrlength <- c(0,seqlengths(TranscriptDb)[paste0("chr",1:22)])
#names(chrlength) <- c(names(chrlength[-1]),"foo")
#chrlength <- rev(rev(chrlength)[-1])
#chrstart <- cumsum(chrlength)
index.vec <- subjectHits(findOverlaps(DF.clean$grange,regions.gr.clean))
DF.clean.list <- split(DF.clean, index.vec)

plot(1, type = "n", xlim = c(1,3e9), ylim = c(0,6 ), axes = FALSE, xlab = "", ylab = "" )
for( i in 1:length(regions.gr.clean) ){
  points( chrstart[as(seqnames(regions.gr.clean[i]),"character")] + start(DF.clean.list[[i]]$grange), -log10(DF.clean.list[[i]]$p.vec), pch = 20, col = i)
}
lines( c(1,(chrstart+chrlength)[22]), rep(-log10(0.05/n),2), lty = 3)
axis(1, chrstart, label = paste0("chr",1:length(chrstart)))
axis(2)
@ 
<<phist, fig = TRUE,  eval = FALSE, echo = FALSE, cache = FALSE>>=
with(as(values(regions.gr.clean),"data.frame"),hist(p.min, breaks = 10))
@ 
<<transvp3, fig = TRUE, eval = FALSE, echo = FALSE, cache = FALSE>>=
#regions.gr <- regions.gr[-which(values(regions.gr)$n.cmp >= 120)]
layout(mat=matrix(1:4, nrow = 2, ncol = 2 ))
with(as(values(regions.gr.clean),"data.frame"),plot(trans.median, -log10(p.min), pch = 20))
with(as(values(regions.gr.clean),"data.frame"),plot(n.cmp, -log10(p.min), pch = 20))
with(as(values(regions.gr.clean),"data.frame"),plot(n.cmp, trans.median, pch = 20))
with(as(values(regions.gr.clean),"data.frame"),plot(width(regions.gr.clean), n.cmp, pch = 20))
@ 

== New Counting Method ==

<<regions>>=
reduce(rowData(fe.beaty))
@

<<trioStates2, eval = TRUE, echo = FALSE, cache = TRUE>>=
trans.mat <- c()
i <- 1 # index for regions
n.reg <- length(reduce(rowData(fe.beaty)))
system.time(
for( i in 1:n.reg){
fe.beaty.i <- fe.beaty[subjectHits(findOverlaps(reduce(rowData(fe.beaty))[i], rowData(fe.beaty)))]
fe.pitt.i <- fe.pitt[subjectHits(findOverlaps(reduce(rowData(fe.pitt))[i], rowData(fe.pitt)))]

if( length(rowData(fe.beaty.i)) > 1 ){
    trioAssay.beaty <- trioClasses:::TrioAssay(fe.beaty.i, type = "cnv")
    trioStates.beaty <- with(trioAssay.beaty, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.beaty) <- dimnames(trioAssay.beaty$O)

    trioAssay.pitt <- trioClasses:::TrioAssay(fe.pitt.i, type = "cnv")
    trioStates.pitt <- with(trioAssay.pitt, matrix( paste0(F,M,O), nrow = nrow(O), ncol = ncol(O)))
    dimnames(trioStates.pitt) <- dimnames(trioAssay.pitt$O)

    trans.beaty.logical <- rowSums(matrix(trioStates.beaty %in% c("011","101","111","112","122","212"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0

    untrans.beaty.logical <- rowSums(matrix(trioStates.beaty %in% c("010","100","111","110","121","211"), nrow = nrow(trioStates.beaty), ncol = ncol(trioStates.beaty), byrow=FALSE)) > 0

    trans.beaty <- sum(trans.beaty.logical)

    untrans.beaty <- sum(untrans.beaty.logical & !trans.beaty.logical)

    trans.pitt.logical <- rowSums(matrix(trioStates.pitt %in% c("011","101","111","112","122","212"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0

    untrans.pitt.logical <- rowSums(matrix(trioStates.pitt %in% c("010","100","111","110","121","211"), nrow = nrow(trioStates.pitt), ncol = ncol(trioStates.pitt), byrow=FALSE)) > 0

    trans.pitt <- sum(trans.pitt.logical)

    untrans.pitt <- sum(untrans.pitt.logical & !trans.pitt.logical)

    trans.mat <- rbind( trans.mat, c(trans.beaty, untrans.beaty, trans.pitt, untrans.pitt) )
}else{
    trans.mat <- rbind( trans.mat, c(NA,NA,NA,NA) )
}
}
)
colnames(trans.mat) <- c("trans.cleft","untrans.cleft", "trans.con","untrans.con")
save(trans.mat, file = "./../data/trans.mat.RData")
@
<<loadtrans, eval = FALSE, echo = FALSE, cache = FALSE>>=
load(file = "./../data/trans.mat.RData")
@
<<transrate, echo = FALSE, eval = TRUE, cache = FALSE>>=
transrate.cleft <- trans.mat[,"trans.cleft"]/rowSums(trans.mat[,c("trans.cleft","untrans.cleft")])
transrate.con <- trans.mat[,"trans.con"]/rowSums(trans.mat[,c("trans.con","untrans.con")])
transrate.all <- rowSums(trans.mat[,c("trans.cleft","trans.con")])/rowSums(trans.mat[,c("trans.cleft","untrans.cleft","trans.con","untrans.con")])
@
<<testable, cache = FALSE, results = verbatim>>=
TU.mat <- trans.mat
testable <- which(   (rowSums(TU.mat[,1:2])>=25) & (rowSums(TU.mat[,3:4])>=25) )
TU.mat <- TU.mat[testable,]
@
<<testable2, echo = FALSE, eval = TRUE, cache = FALSE>>=
rownames(TU.mat) <- names(table.list.beaty)[testable]
colnames(TU.mat) <- c("T.case","U.case","T.con","U.con")
DF <- DataFrame(reduce(rowData(fe.beaty))[testable],TU.mat)
colnames(DF) <- c("grange", colnames(TU.mat))
@
<<TUfish, eval = TRUE, echo = TRUE, cache = FALSE>>=
trioClasses:::TU.fish
@
<<fish2, eval = TRUE, echo = TRUE, cache = FALSE>>=
fish.list <- apply(TU.mat,1,trioClasses:::TU.fish)
p.vec <- unlist( lapply( fish.list, function(obj) return(obj$p.value) ) )
DF <- DataFrame(DF,p.vec,transrate.all[testable])
head(as(DF[with(as(DF,"data.frame"),order(p.vec)),],"data.frame"))
@
<<headtrans, eval = TRUE, echo = TRUE, cache = FALSE>>=
head(as(DF[with(as(DF,"data.frame"),order(transrate.all.testable.)),],"data.frame"))
@ 
<<transhist, fig = TRUE, cache = FALSE,  height=6, width = 6, eval = TRUE>>=
hist(DF$transrate.all.testable.)
@
<<cifigcleft, fig = TRUE, cache = FALSE>>=
htest.list.cleft <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.cleft[[i]] <- binom.test(TU.mat[i,"T.case"],sum(TU.mat[i,c("T.case","U.case")]))
}
ci.list.cleft <- lapply(htest.list.cleft, trioClasses:::get.ci)
ci.mat.cleft <- matrix(unlist(ci.list.cleft),nrow = length(htest.list.cleft), ncol = 2, byrow = TRUE )
o <- order(DF$transrate.all.testable.)
plot(1, type = "n", xlim = c(1,nrow(ci.mat.cleft)), ylim = c(0,1), xlab = "Deleted Regions", ylab = "Cleft Transmission Rate", main = "" )
polygon( x = c(x <- 1:nrow(ci.mat.cleft), rev(x)), y = c(ci.mat.cleft[o,1],rev(ci.mat.cleft[o,2])),col = "orange", border = "black")
lines( c(1,nrow(ci.mat.cleft)), rep(0.5,2), lty = 3 )
@
<<cifigcon, fig = TRUE, cache = FALSE, echo = FALSE>>=
htest.list.con <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.con[[i]] <- binom.test(TU.mat[i,"T.con"],sum(TU.mat[i,c("T.con","U.con")]))
}
ci.list.con <- lapply(htest.list.con, trioClasses:::get.ci)
ci.mat.con <- matrix(unlist(ci.list.con),nrow = length(htest.list.con), ncol = 2, byrow = TRUE )
o <- order(DF$transrate.all.testable.)
plot(1, type = "n", xlim = c(1,nrow(ci.mat.con)), ylim = c(0,1), xlab = "Deleted Regions", ylab = "Con Transmission Rate", main = "" )
polygon( x = c(x <- 1:nrow(ci.mat.con), rev(x)), y = c(ci.mat.con[o,1],rev(ci.mat.con[o,2])),col = "blue", border = "black")
lines( c(1,nrow(ci.mat.con)), rep(0.5,2), lty = 3 )
@
<<cifigall, fig = TRUE, cache = FALSE, echo = FALSE>>=
htest.list.all <- list(NA, length = nrow(TU.mat))
for( i in 1:nrow(TU.mat) ){
     htest.list.all[[i]] <- binom.test(sum(TU.mat[i,c("T.case","T.con")]), sum(TU.mat[i,c("T.case","U.case","T.con","U.con")]))
}
ci.list.all <- lapply(htest.list.all, trioClasses:::get.ci)
ci.mat.all <- matrix(unlist(ci.list.all),nrow = length(htest.list.all), ncol = 2, byrow = TRUE )
o <- order(DF$transrate.all.testable.)
plot(1, type = "n", xlim = c(1,nrow(ci.mat.all)), ylim = c(0,1), xlab = "Deleted Regions", ylab = "All Transmission Rate", main = "" )
polygon( x = c(x <- 1:nrow(ci.mat.all), rev(x)), y = c(ci.mat.all[o,1],rev(ci.mat.all[o,2])),col = "green", border = "black")
lines( c(1,nrow(ci.mat.all)), rep(0.5,2), lty = 3 )
@
.How do we filter regions that are undertransmitted?
* Any region whose overall transmission rate CI does not cover 0.5
